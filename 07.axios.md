### 一、URL
1. **URL**: 统一资源定位符，用于定位互联网上的资源，简称网址
2. **参数**: `http://xxxxx.com/xxx/xxx?参数名=参数值&参数名2=参数值2`
```javascript
//查询数据
axios({
  url: 'http://xxxxx.com/xxx/xxx',
  method: 'get',
  params: { // 参数
    参数名: 参数值,
    }
}).then(result => { // 请求成功的后续处理
}).catch(error => { // 请求失败的异常处理
})
//提交数据
axios({
  url: 'http://xxxxx.com/xxx/xxx',
  method: 'post',
  data: { // 提交数据
    参数名: 参数值,
}
}).then(result => { // 提交成功的后续处理
}).catch(error => { // 提交失败的异常处理
})
```
3. **form-serialize**: 快速收集提交表单的数据
```javascript
const form = document.querySelector('#form');
//hash: 设置获取数据结构, true: JS对象, false: 查询字符串
//empty: 设置是否包含空值, true: 获取空值, false: 不获取空值
const data = serialize(form, { hash: true, empty: true });
```
### 二、Ajax原理 
axios原理基于XMLHttpRequest，通过XMLHttpRequest对象发送请求，并接收响应数据。
1. **XMLHttpRequest使用**: 
  1.创建XMLHttpRequest对象: `const xhr = new XMLHttpRequest()`;
  2.配置请求方法和URL: `xhr.open('GET', 'https://api.example.com/data')`;
    查询参数获取:   `const xxx = {xxxxx...}; const params = new URLSearchParams(xxx)`;
  3.监听loadend事件: `xhr.addEventListener('loadend', () => { console.log(xhr.response) })`;
    若是POST请求, 需要设置请求头: `xhr.setRequestHeader('Content-Type', 'application/json')`;
    封装数据: `const xxx = {xxxxx...}`;
    发送数据: `xhr.send(JSON.stringify(xxx))`;
  4.发送请求: `xhr.send()`;
2. **Promise**:
  1.promise状态：
    `pending`: 等待状态;
    `fulfilled`: 兑现状态;
    `rejected`: 拒绝状态;
    一旦状态被兑现/拒绝，就不可改变;
  2.Promise使用: 
```javascript
//创建Promise对象(pending状态)
const promise = new Promise((resolve, reject) => {
  //执行异步代码
  setTimeout(() => {
    resolve('成功'); //改变状态为兑现状态
    reject('失败'); //改变状态为拒绝状态
  }, 2000);
  });
  //获取结果
  promise.then(result => {
    console.log(result);
  }).catch(error => {
    console.log(error);
  })
```
### 三、同步代码和异步代码
1. **同步代码：** 逐行执行，原地等待结果后，再继续向下执行
2. **异步代码：** 不阻塞代码继续执行，将来完成后触发回调函数
3. **解决回调函数地狱问题- promise链式调用：**
   依靠then()方法，返回一个新生成的promise对象，继续串联下一环任务
   then()的返回值会影响新生成的promise对象的状态和结果
```javascript
// 创建promise对象
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('成功');
  }, 2000);
})
const promise2 = promise.then(value => {
  console.log(value); //获取第一个promise的返回值
  return new Promise((resolve, reject) => { //返回一个promise对象链式调用
    setTimeout(() => {
      resolve('成功2');
    }, 2000);
  })
})
promise2.then(value => {
  console.log(value); //获取第二个promise的返回值，避免了回调函数嵌套的问题
});
```
4. **async/await**
   async函数内使用await关键字取代then函数，等待Promise对象返回结果
```javascript
async function getData() {
  try{
    let promise = await axios({url: 'https://xxx.com/api/xxx', method: 'get'});
  }.catch(err) {
    console.log(err);
  }
}
```
5. **宏任务与微任务**
   1.**宏任务**：由浏览器环境执行的异步代码：setTimeout、setInterval、JS脚本、AJAX请求、DOM事件
   2.**微任务**：由JS引擎执行的异步代码：Promise.then(Promise本身是同步，then和catch是异步)
```javascript
console.log(1);
setTimeout(() => {
  console.log(2);
  const p = new Promise(resolve => resolve(3));
  p.then(res => console.log(res));
}, 0);
const p = new Promise(resolve =>{
  setTimeout(() =>{
    console.log(4);
  }, 0)
  resolve(5);
 });
 p.then(res => console.log(res));
 const p2 = new Promise(resolve => resolve(6));
 p2.then(res => console.log(res));
 console.log(7);
 // 1 7 5 6 2 3 4
 ```
6. **promise.all静态方法**
   合并多个promise对象，等待所有同时成功完成，再做后续逻辑。
```javascript
const p = Promise.all([promise1对象, promise2对象, ...]);
p.then(res => {
  // res为所有promise对象成功返回的数组
}).catch(err =>{
  // err为第一个promise对象失败抛出的异常
});
```
