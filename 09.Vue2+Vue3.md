### 一、Vue
1. **Vue**: 是一个用于构建用户界面的渐进式框架。
   基于数据渲染用户看到的界面。
   两种开发方式：基于核心包的局部模块改造，基于Vue工程化的整站开发
   有一套完整的项目解决方案，提升开发效率
2. **Vue对象**：
   ```javascript
   const app = new Vue({
     el: '#app', //需要控制的元素id
     data: { //提供需要渲染数据
     },
     methods: { //提供方法函数
     //methods中的this会指向Vue实例
     }
   })
   ```
### 二、插值表达式
1. **插值表达式**：`{{}}` 插值表达式，用于将数据渲染到页面中
   支持普通的变量渲染 `{{ msg }}`
   支持对象属性渲染 `{{ obj.name }}`
   支持三元表达式 `{{ obj.age > 18 ? '成年' : '未成年' }}`
   支持字符串拼接 `{{ '姓名：' + obj.name }}`
   支持方法调用 `{{ obj.getName() }}`
   不能是语句，例如if、for、while等
### 三、Vue指令
1. **v-html**：用于将数据渲染到页面中，数据会被解析为HTML，相当于innerHTML属性
2. **v-show = "表达式"**：用于控制元素是否显示，值为true时显示，值为false时隐藏
   本质上是通过控制元素的display属性来实现的，一般用于频繁切换的场景
3. **v-if = "表达式"**：用于控制元素是否显示，值为true时显示，值为false时隐藏
   本质上是通过判断条件来控制元素的创建和移除，一般用于不频繁切换的场景
   **v-else** **v-else-if**：辅助v-if使用进行判断渲染
4. **v-on: 事件名="内联语句"** / **v-on:事件名="method的函数名"**：用于监听事件，提供处理逻辑
   可以将`v-on`写成`@`
   **传参**: `v-on:click="handleClick(参数1, 参数2...)"`
5. **v-bind:属性名="内联语句"**：用于绑定属性，课简写为`:属性名="内联语句"`
6. **v-for**：用于循环渲染, 可循环渲染数组、对象、字符串...
   `v-for="(item, index) in items"`
   item: 每一项
   index: 索引(若不需要可省略)
   使用`v-for`后还需要绑定key属性：`:key="item.id"`
   **key**: `:key = "唯一标识"` 给列表项添加唯一标识，便于Vue进行列表项的正确排序复用。
   若不加key属性，Vue会默认原地修改元素，就地复用。
   不推荐用index索引作为key属性，index会变化
7. **v-model**: 双向数据绑定 
   `v-model="变量名"`
   **作用**: 给表单元素使用，可以快速获取或设置表单元素的内容
8. **指令修饰符**: 通过`.`指明一些指令后缀，不同后缀封装了不同的处理操作
   **按键修饰符:** 
   @keyup.enter  键盘回车监听
   **v-model修饰符:** 
   v-model.trim  去除前后空格
   v-model.number  将输入内容转为数字
   **事件修饰符**: 
   @事件名.stop  阻止事件冒泡
   @事件名.prevent  阻止默认事件
9. **v-bind操作class**: 
   **语法**: `class = "对象/数组"`
   **关于对象**: 键名是类名，键值是布尔值，如果值为true，则添加该类名，否则不添加。
   适用于一个类名来回切换
   `<div class="box" :class="{类名1: 布尔值, 类名2: 布尔值, ...}"> </div>`
   **关于数组**: 数组中包含的类名，则添加该类名，否则不添加。
   适用于批量添加或删除类名
   `<div class="box" :class="['类名1', '类名2', ...]"> </div>`
   **v-bind操作css**: 用于操作单个的css样式
   `<div class="box" :style="{css属性名: css属性值, css属性名: css属性值, ...}"> </div>`
10. **v-model用于其他表单元素**:
    会根据控件类型，自动选择合适的方法更新元素
    `<input type="text" v-model="变量名">`
    `<textarea v-model="变量名">`
    `<select v-model="变量名" value="选项值">`
    `<input type="checkbox" v-model="变量名" value="选项值">`
    `<input type="radio" v-model="变量名" value="选项值">`
11. **计算属性**: 基于现有的数据，计算出来的新属性。依赖数据变化，自动重新计算。
    **语法**:
    方式一: 在computed配置项中，一个计算属性对应一个函数
    `computed: { 属性名() {xxx计算逻辑; return 计算值 } }` 
    在html中访问: `{{ 属性名 }}`属性名后不加括号
    对比使用方法计算，computed计算属性会缓存，再次使用时就会直接读取缓存，提升性能，直到依赖项变化才会重新计算，然后重新缓存新值。
    关于计算属性的完整写法：
    ```javascript
    computed: { 
      计算属性名: { 
        get() { //当被获取求值时执行
          xxx计算逻辑;
          return xxx结果;
        },
        set(修改的值) {  //当计算属性被修改赋值时执行
          xxx计算逻辑;
        }
      }
    }
    ```
    方式二: 使用方法来计算，最后调用方法来获取计算结果
    `methods: { 函数名() {xxx计算逻辑; return 值 } }`
    `<div>{{ 函数名() }}</div>`
12. **watch**: 监听数据变化，执行对应的处理逻辑
    **语法**:
    简单写法: 简单数据类型，直接监视
    ```javascript
    data() { 
      word: 'xxx',
      obj: {
         word: 'xxx'
       }
    },
    watch: { 
      数据属性名(newValue, oldValue) { //newValue: 新值，oldValue: 旧值
        xxx处理逻辑;
      },
      '对象.属性名'(newValue, oldValue) { //newValue: 新值，oldValue: 旧值
        xxx处理逻辑;
      }
    }
    ```
    完整写法：添加额外配置项
    `deep: true`, 对复杂类型深度监视
    `immediate: true`, 初始化后立刻执行一次handler方法
    ```javascript
    watch: {
      data属性名: {
         deep: true,
         immediate: true,
         handler(newValue, oldValue) { //newValue: 新值，oldValue: 旧值
         xxx处理逻辑;
         }
      }
    }
    ```
### 四、生命周期
1. **Vue的生命周期:** Vue实例从创建到销毁的过程。
   **创建阶段**: 响应式数据
   **挂载阶段**: 渲染模板
   **更新阶段**: 数据变化，重新渲染模板
   **销毁阶段**: 销毁实例
2. **生命周期函数**: Vue实例创建、挂载、更新、销毁时，会执行对应的生命周期函数。
   被称为生命周期钩子，可以让开发者在特定阶段运行对应的代码。
   一般在created中发送初始化渲染请求：
   ```javascript
   async created() {
      const res = await axios.get('xxx');
      this.list = res.data;
    }
   ```
   在mounted中操作dom。
   ```javascript
   //搜索框渲染完成后立刻获得焦点
   mounted() {
      this.$refs.search.focus();
   }
   ```
   在beforeDestroy中销毁实例。
###　五、工程化Vue项目
1. **Vue项目创建**: 
   全局安装: `npm install -g @vue/cli` (只需操作一次)
   查看版本: `vue -V`
   创建项目: `vue create 项目名(不能中文)`
   启动项目: `npm run serve`
2. **Vue项目结构**: 
   * **node_modules**: 第三方文件夹
   * **public**: 存放html文件
     favicon.ico: 网站图标 
     index.html: 模板文件
   * **src**: 源代码目录
     assets: 静态资源文件夹: 图片、字体、样式文件
     components: 组件文件夹: 通用组件
     App.vue: 根组件, 项目中运行看到的内容
     main.js: 项目入口文件，打包或运行第一个执行的文件
   * **.gitignore**: git忽略文件
   * **babel.config.js**: babel配置文件
   * **jsconfig.js**: js配置文件
   * **package.json**: 项目依赖包版本信息 (包含项目名、版本号、scripts、依赖包)
   * **README.md**: 项目说明文件
   * **vue-config.js**: vue配置文件
   * **package-lock.json**: 项目依赖包版本信息, 锁定安装版本
### 五、组件化开发
1. **组件化开发**: 组件化开发，将页面拆分为多个组件，每个组件是一个独立的功能块，组件之间可以进行数据传递。
   便于维护，利于复用
2. **App.vue组成**:
   **`<template>`**: 结构(Vue2有且只有一个根标签)
   **`<style>`**: 样式, 支持less, 使用less时要安装:`npm i less less-loader -D`
   若要其只作用于当前组件, 则在style标签中添加scoped属性
   `scoped`会通过给当前组件添加`data-v-dash`值得属性，从而实现样式的隔离
   **行为逻辑:** 
   el是根实例独有，data是一个函数，其他配置项一致
   ```javascript
   export default {
      methods: {
         //逻辑
      }
   }
   ```
3. **组件注册**:
   * **局部注册**:
     创建.vue文件；
     在使用的组件内导入并注册：
     ```javascript
     import 组件对象 from '.vue的文件路径'
     export default {
       components: {
         //局部注册
         '组件名': 组件对象,
       }
     }
     ```
   * **全局注册**:
     创建.vue文件；
     在main.js中导入并注册：
     ```javascript
     import 组件对象 from '.vue的文件路径'
     Vue.component('组件名', 组件对象)
     ```
     所有组件内都能使用
   * **组件使用**:
     当成html来使用`<组件名>`
     组件的命名规范: 大驼峰命名
4. **data函数**：
   data函数会保证每个组件实例是独立的，不会相互干扰
   ```javascript
   data() {
      return {
         data: '数据'
      }
   }
   ```
5. **组件通信**:
   **组件之间的关系**: 
   父子关系: `props` 和 `$emit`
   **props**: 父组件向子组件传递数据
   **$emit**: 子组件发送事件给父组件
   ```html
   <!-- 父组件 -->
   <!-- 结构部分 -->
   <!-- 父向子传递数据时，需要绑定属性，子修改父的数据时需要监听事件 -->
   <Child :title="title" @changeTitle="handleChange"></Child>
   <!-- 逻辑部分 -->
   <script>
      import Child from './Child.vue'
      export default {
         data() {
            return {
               title: 'hello world', // 父组件的数据
            }
         },
         methods: { // 提供处理函数用于处理子组件发送的事件
            handleChange(newTitle) {
               this.title = newTitle
            }
         },
         components: {
            Child,
         }
      }
   </script>
   <!-- 子组件 -->
   <!-- 结构部分 -->
   <template>
     <div>{{ title }}</div>
     <button @click="changeTitle">修改title</button>
   </template>
   <!-- 逻辑部分 -->
   <script>
   export default {
      //通过props接收父组件传递的title
      props: ['title'], //若要传递多个参数，使用逗号隔开
      methods: {
         changeTitle() {
            //通过$emit向父组件发送事件
            this.$emit('changeTitle', 'new title')
         }
      }
   }
   </script>
   ```
   **关于props校验**:
   `props: { 校验的属性名: 指定数据类型 }`
   完整写法：
   ```javascript
   props: {
      校验的属性名: {
         type: 指定数据类型,
         required: 是否必填, //(true/false)
         default: 默认值,
         validator(value){ //自定义校验函数
            return 是否通过校验;
         }  
      }
   }
   ```
   **关于prop和data**:
   共同点：都可以给组件提供数据
   不同点：prop数据时外部的，需要修改时要遵循单向数据流的原则，由子组件向父组件传递修改事件，而data数据时内部的，可以任意修改。
   单项数据流：父级prop的数据更新会向下流动，影响到子组件，并且该流向是单向的。
   原则: 谁的数据谁负责
   **非父子关系通信**: `provide / inject / eventbus`
   **event bus总线**: 非父子组件之间，进行简易的消息传递(复杂场景需要使用Vuex)
   1.创建一个所有组件均可使用的事件总线(空Vue实例) `utils/eventBus.js`
     ```javascript
     import Vue from 'vue'
     const Bus = new Vue()
     export default Bus
     ```
   2.A组件(接收方)，监听Bus实例的事件
     ```javascript
     created() {
       Bus.$on('eventName', (data) => {
         this.data = data;
       })
     }
     ```
   3.B组件(发送方)，发送事件
     ```javascript
     Bus.$emit('eventName', data)
     ```
   **inject/provide**: 跨层级共享数据
   1.A组件(提供方)，定义一个属性
   ```javascript
   provide() {
      return {
         xxx: this.xxx,
         ...
      }
   }
   ```
   2.B组件(接收方)，注入数据
   ```javascript
   inject: ['xxx', ...],
   created() {
      console.log(this.xxx, ...)
   }
   ```
6. **v-model原理**: 
   本质上是语法糖
   通过`:value = "变量名"`绑定数据，通过`@input = $event.target.value`事件监听数据变化 
   **表单类组件封装：**
   父传子：父组件props传递数据，v-model拆解绑定数据
   子传父：监听输入，子传父值给父组件修改
   下拉框修改数据
   ```html
   <!-- 父组件app.vue -->
   <template>
      <div>
         <!-- <BaseSelect :value="cityId" @input="selectId = $event" /> -->
         <!-- 上述代码可简化成: -->
         <BaseSelect v-model="selectId" />
      </div>
   </template>
   <script>
      export default {
         data() {
            return {
               selectId: xxx
            }
         },
      }
   </script> 
   <!-- 子组件BaseSelect.vue -->
   <template>
      <select :value="value" @change="handleChange"> </select>
   </template>
   <script>
      export default {
         props: {
            value: String,
         },
         methods: {
            handleChange(e) {
               this.$emit('input', e.target.value)
            }
         }
      }
      ``` 
7. **.sync修饰符实现双向绑定**
   `.sync`修饰符prop属性名可以自定义，而非固定为value
   `visible.sync = "变量名"`本质上是`:属性名 = "value"`和`@update:属性名="value = $event"`的简写
   ```html
   <!-- 父组件 -->
   <BaseDialog :visible.sync="isShow"></BaseDialog>
   <!-- 等价于 -->
   <BaseDialog :visible="isShow" @update:visible="isShow = $event"></BaseDialog>
   <!-- 子组件 -->
   <script>
      export default {
         props: {
            visible: boolean,
         },
         this.$emit('update:visible', false)
      }
   </script>
   ```
8. **ref和`$refs`**
   作用: 获取dom元素或组件实例
   特点: 在当前组件内查找，更精确稳定，querySelector的范围是整个页面
   1.添加ref属性
   `<input ref="myDiv"></input>`
   2.获取元素
   `this.$refs.myDiv`
9. **Vue异步更新 / `$nextTick`** 
   **`$nextTick`**: 等DOM更新完毕，再执行此方法中的函数体
   `this.$nextTick(() => {this.$ref.myDiv.focus()})`等DOM更新完毕，再获取输入框的焦点
   可以
### 六、自定义指令
1. **自定义指令**: 封装常见的dom操作，扩展功能
   **全局注册**:
   ```javascript
   Vue.directive('指令名', {
      inserted (el) { // inserted: 元素插入到DOM中时执行
         el.focus()
      }
   })
   ```
   **局部注册**:
   ```javascript
   export default {
      directives: {
         "指令名": {
            inserted (el) { // inserted: 元素插入到DOM中时执行
               el.focus();
            }
         }
      }
   }
   ```
   使用时：`<input v-指令名 type="text">`
### 七、插槽
1. **插槽**: 让组件内部的结构支持自定义
   **使用方法**: 
   组件内部需要定制结构的部分，使用`<slot></slot>`包裹 
   使用组件时，在标签内部传入结构替换`<slot>`
   ```html
   <!-- 组件内部结构 -->
   <template>
      <div>
         <!-- 此处的后备内容，当外部组件没有传入结构时，就会显示该处的内容 -->
         <slot>后备内容</slot>
      </div>
   </template>
   <!-- 使用组件 -->
   <BaseDialog>
   <!-- 此处可以添加多个结构，结构会替换slot标签中的内容 -->
       <div>自定义结构</div>
   </BaseDialog>
   ```
   **具名插槽**: 
   ```html
   <!-- 组件内部结构: 多个slot使用name属性区分 -->
   <template>
      <div>
         <slot name="title"></slot>
      </div>
      <div>
         <slot name="content"></slot>
      </div>
      <div>
         <slot name="footer"></slot>
      </div>
   </template>
   <!-- 使用组件: template标签配合v-slot分发插槽 -->
   <BaseDialog>
       <template v-slot:title>标题</template>
       <template v-slot:content>内容</template>
       <template v-slot:footer>底部</template>
   </BaseDialog>
   ```
   **作用域插槽**: 插槽的一种语法，不属于分类的一种
   定义slot时，是可以传值的，给插槽绑定数据
   使用:
   1.给slot绑定数据
   `<slot name="title" :id="item.id" msg="数据"></slot>`
   2.所有添加上的属性都会被收集到一个对象中
   `{id: num, msg: '数据'}`
   3.在`<template>`中，使用通过`#插槽名="obj"`接收，默认插槽名为`default`
   ```html
   <template #title="obj">
     <div>{{obj.id}}</div>
     <div>{{obj.msg}}</div>
   </template>
   ```
### 八、VueRouter
1. **VueRouter**: 封装了路由功能，实现单页面应用
2. **使用**:
   1.安装: 
   vue2使用的是`npm install vue-router@3.6.5` 或者`yarn add vue-router@3.6.5`
   vue3使用的是`npm install vue-router@4.0.0` 或者`yarn add vue-router@4.0.0`
   2.引入
   `import VueRouter from 'vue-router'`
   3.注册
   `Vue.use(VueRouter)`
   4.创建路由对象
   `const router = new VueRouter()`
   5.将路由对象注入new Vue实例中
   `new Vue({ render: h => h(App), router }).$mount('#app')`
   6.创建路由规则
   ```javascript
   import 组件名 from '组件路径'
   ...
   const routes = new VueRouter({
      routes: [
         { path: '/路径名', component: 组件名 },
         ...
      ]
   })
   ```
   7.使用路由
   ```html
   <div>
      <a href="#/路径名">跳转</a>》
      ...
   </div>
   <div>
      <!-- 该标签相对a标签放在哪，就显示在a标签的相对位置，此处会显示在a标签的下方 -->
      <router-view></router-view>
   </div>
   ```
   8.**实际项目中，凡是单独展示的页面都是一级路由**
3. **文件存放目录问题**:
   页面文件要放在`src/views`目录下, 页面展示, 配合路由用
   组件文件要放在`src/components`目录下, 展示数据
4. **抽离路由，重新封装**: 代码放在`src/router/index.js`
   ```javascript
   //在index.js中创建路由对象
   import Vue from 'vue'
   import VueRouter from 'vue-router'
   //@表示从src目录逐级寻找组件
   import 组件名 from '组件路径@/xxx/...'  
   ...
   Vue.use(VueRouter)
   const routes = new VueRouter({
      routes: [
         { path: '/路径名', component: 组件名 },
         ...
      ]
   })
   export default routes
   //在main.js中引入并使用
   import routes from './router/index.js'
   ```
5. **声明式导航**:
   使用`<router-link>`标签
   `<router-link to="/路径名">跳转</router-link>`
   该标签会提供两个高亮类名，可以直接设置高亮样式
   `router-link-active`: 模糊匹配 可以匹配/xx, 以及/xx/**的路由
   `router-link-exact-active`: 严格匹配，仅匹配/xx的路由
   自定义类名:
   ```javascript
   const router = new VueRouter({
      routes: [...],
      linkActiveClass: '类名1', //模糊匹配
      linkExactActiveClass: '类名2' //精确匹配
   })
   ```
6. **跳转传参**:
   在跳转路由时，进行传值: (适用于传输多个参数)
   1.查询参数传参: `to="/path?参数名=参数值"`
     接收传递的值: `this.$route.query.参数名`
   2.动态参数传参: (适用于单个参数传参)
   ```javascript
   const router = new VueRouter({
      routes: [
         ...,
         {
            path: '/path/:word',
            component: () => import('组件路径'),
         }
      ]
   })
   ```
   跳转: `to="/path/参数值"`
   接收传递的值: `this.$route.params.word`
7. **重定向**:
   在`routers`中配置: `{ path: '/', redirect: '/path' }`, 打开首页时会跳转到`/path`页面。
8. **404错误处理**:
   在`routers`中配置: `{ path: '*', component: 组件名) }`, 匹配不到路由时跳转到该组件。
9.  **路由模式**:
   默认是hash模式, 如`http://localhost/#/path`
   可以通过`mode: 'history'`改为history模式。如`http://localhost/path`
### 九、编程式导航
1. **基本跳转**
   **path**: 适合短链接
   `this.$router.push('/路径名')`
   完整写法：
   `this.$router.push({ path: '/路径名' })`
   **name**: 适合长链接
   `this.$router.push({ name: '路由名' })`
   完整写法:
   `this.$router.push({ name: '路由名', path:'/路径名', component: 组件名 })`
2. **路由传参**:
   传参方式：查询参数 + 动态路由传参
   **关于path**:
   query传参:
   ```javascript
   this.$router.push({ path: '/路径名', query: { 参数名: 参数值 } })
   this.$router.push('/路径名?参数名=参数值')
   ```
   动态路由传参:
   ```javascript
   this.$router.push({ path: '/路径名/:参数名'})
   this.$router.push('/路径名/参数值')
   ```
   **关于name**:
   query传参:
   ```javascript
   this.$router.push({ name: '路由名称', query: { 参数名: 参数值 } })
   ```
   动态路由传参:
   ```javascript
   this.$router.push({ name: '路由名称', params: { 参数名: 参数值 } })
   ```
### 十、自定义创建项目
1. **基于vue-cli创建项目**: 
   使用命令创建项目: `vue create 项目名`
   选择`Manually select features`，
   然后选择`babel`、`router`、`Linter / Formatter`，
   下一步选择版本 `2.x / 3.x`
   下一步选择router模式，`hash / history`
   下一步选择CSS预处理器，`Sass / Less / Stylus`
   下一步选择linter，`ESLint + Standard config(无分号规范)`
   下一步选择校验，`lint on save`
   最后选择将配置文件放在哪，`In dedicated config files`
### 十一、ESLint
1. **ESLint**: 是一个 JavaScript 语法和风格检测工具
### 十二、Vuex
1. **Vuex**: Vuex 是一个专为 Vue.js 应用程序开发的状态管理库。用来管理Vue通用的数据(多组件共享数据)
2. **场景**: 当某个状态需要在多个组件间共享时，或多个组件要共同维护一份数据
3. **作用**: 集中化管理数据，响应式变化，操作简洁
4. **使用步骤**:
   1.安装: `npm install vuex@(Vue2版本使用3.x, Vue3版本使用4.x)`
   2.创建store文件夹，创建index.js文件，并引入Vuex
   3.引入Vuex
   4.创建Store对象
   5.导出Store对象给根组件使用
   ```javascript
   // /store/index.js
   import Vue from 'vue'
   import Vuex from 'vuex'
   Vue.use(Vuex)
   const store = new Vuex.Store({
      // state状态，类似于Vue中的data
      // data是组件自己的数据，store是整个项目组件共享的数据
      state: {
         count: 101
      }
   })
   export default store
   // /main.js
   import store from './store'
   ...
   new Vue({
      ...
      store,
   }).$mount('#app')
   ```
5. **使用state中的共享数据**:
   在模板中: `{{ $store.state.count }}`
   组件逻辑中: `this.$store.state.count`
   Js逻辑中: `store.state.count` 
   **使用辅助函数获取数据**:
   1.导入mapState辅助函数: `import { mapState } from 'vuex'`
   2.数组方式引入state: `mapState(['count'])`
   3.展开运算符映射: `computed: { ...mapState(['count']) }`
   **Vuex的数据修改**:
   应当遵循单向数据流，不能在组件中直接修改(不合规范)。
   1.定义mutations对象，对象中存放修改数据的方法
   ```javascript
   const store = new Vuex.Store({
      state: {
         count: 0
      },
      mutations: {
         add(state) {
            state.count++
         }
      }
   })
   ```
   2.组件中通过`this.$store.commit('方法名')`来调用mutations中的方法
   3.`mutations`传参: `this.$store.commit('方法名',参数)`
   在函数的括号中接收参数: `mutations: { add (state, n) { state.count += n } }`
   Vuex中不能传递多个参数，若要传递多个参数，需要将参数放在一个对象中: 
   `this.$store.commit('方法名',{n:1,m:2})`
   在Vuex中，不能使用`v-model`进行数据绑定，应该使用`:value`和`@input` 
   4.`mapMutations`辅助函数: 
   先引入: `import { mapMutations } from 'vuex'`
   再使用: `methods: {...mapMutations(['方法名1','方法名2'])},`
   该函数将Vuex中的方法映射到局部计算属性中,此时可以使用`this.方法名(参数)`进行调用
6. **`actions`**: 
   上面的`mutations`必须是同步的,而`actions`是可以处理异步操作
   **使用：**
   ```javascript
   actions: {
      changeCount(context, num) { //context可等价于store对象
         setTimeout(() => {
            context.commit('changeCount', num)
         }, 1000)
      }
   }
   ```
   调用: `this.$store.dispatch('setCount', 10)`
   **mapActions**: 将actions映射到methods中
   1.引入mapActions: `import { mapActions } from 'vuex'`
   2.使用: `methods: {...mapActions(['changeCount'])}`
   3.调用: `this.changeCount(10)`
7. **getters**:
   相当于computed，用于对state中的数据进行加工处理，返回处理后的数据。
   ```javascript
   // 例子: 选出数组中大于5的数字
   state: {
      arr: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   }
   getters: {
      getArr (state) {
         return state.arr.filter(item => item > 5)
      }
   }
   ```
   获取`getters`: {{ $store.getters.getArr }}
   或者通过辅助函数`mapGetters`:
   ```javascript
   import { mapGetters } from 'vuex'
   export default {
      computed: {
         ...mapGetters(['getArr'])
      }
   }
   ```
   获取`getters`: {{ getArr }}
8. **模块(module)**
   模块拆分:
   创建`store/modules/user.js`:
   ```javascript
   const state = {
      user: {
         name: '张三',
         age: 18
      }
      score: 100
   }
   const getters = {}
   const mutations = {}
   const actions = {}
   export default {
      state,
      getters,
      mutations,
      actions
   }
   ```
   使用时：
   ```javascript
   import user from './modules/user'
   const store = new Vuex.Store({
      modules: {
         user
      }
   })
   ```
   **使用模块中的数据**:
   直接通过模块名访问: `$store.state.user.age`
   通过mapState映射: `mapState(['user'])`
   子模块映射: `mapState('user', ['user'])`
   使用子模块映射需要开启命名空间: `namespaced: true`
   **访问getter**:
   直接通过模块名访问: `$store.getters['模块名/xxx']`
   通过mapGetters映射: `mapGetters(['xxx'])`
   子模块映射: `mapGetters('模块名', ['xxx'])` 
   使用子模块映射需要开启命名空间 
   **调用mutation**:
   默认模块中的`mutation`和`action`方法会被挂载到全局，需要开启命名空间，才会挂载到子模块。
   直接通过store访问: `$store.commit('模块名/xxx', 参数)`
   通过mapMutations映射: `mapMutations(['xxx'])`
   子模块映射: `mapMutations('模块名', ['xxx'])`
   **调用action**:
   和`mutation`基本一致
   通过store访问: `$store.dispatch('模块名/xxx', 参数)`
   通过mapActions映射: `mapActions(['xxx'])`
   子模块映射: `mapActions('模块名', ['xxx'])`
### 十三、Json-server
   json-server是一个基于node.js的mock数据服务器, 可以快速生成模拟数据
1. 安装json-server: `npm i json-server -g`
2. 新建一个db目录
3. 将db.json文件放入db目录中
4. 运行json-server: `json-server db.json`
5. 访问: `http://localhost:3000/users`
### 十四、Vant
  Vant是一个基于Vue的移动端UI组件库
1. **关于全部导入和按需导入的区别：**
   推荐按需导入，因为这样打包出来的文件会更小，速度更快
   全部导入会导致打包出来的文件过大
2. **全部导入:**
   安装: `npm i vant@latest-v2 -S`
   `main.js`注册:
   ```javascript 
   import Vue from 'vue'
   import 'vant/lib/index.css'
   Vue.use(Vant)
   ```
3. **按需导入:**
   安装Vant: `npm i vant@latest-v2 -S`
   安装插件: `npm i babel-plugin-import -D`
   `babel.config.js`配置:
   ```javascript 
   module.exports = {
       presets: [
         '@vue/cli-plugin-babel/preset'
       ],
       plugins: [
         ['import', {
            libraryName: 'vant',
            libraryDirectory: 'es',
            style: true
            }, 'vant']
       ]
   }
   ```
   main.js引入: 
   ```javascript 
   import Vue from 'vue'
   import { Button } from 'vant'
   Vue.use(Button)
   ```
4. **`postcss`插件**:
   **安装**: `npm install postcss-px-to-viewport@1.1.1 -D`
   **根目录新建postcss.config.js**: 
   ```javascript
   module.exports = {
      plugins: {
         'postcss-px-to-viewport': {
            //标准宽度计算: 设计图宽度/2
            viewportWidth: 375, // 标准屏宽度
          }
      }
   }
   ```
### 十五、路由懒加载
1. **路由懒加载**: 
   1.异步组件改造:
   ```javascript
   const ProDetail = () => import('@/views/ProDetail')
   const Pay = () => import('@/views/Pay')
   ...
   ```
   2.路由中应用
   ```javascript
   export default new VueRouter({
      routes: [
         { path: '/proDetail/:id', component: ProDetail },
         { path: '/pay', component: Pay },
         ...
      ]
   })
   ```
   **频繁跳转的页面不需要懒加载，一般是用于少量访问的路由**

- ---
### 一、Vue3
1. **创建项目**: 
   前提：已安装`node.js`16.0以上版本
   创建项目：`npm init vue@latest`
2. **目录结构**:
   **`vite.config.js`**: 配置文件
   **`main.js`**: 入口文件
   **`app.vue`**: 根组件
     与Vue2的区别:
     1.`script`和`template`标签替换位置
     2.`template`标签中不再只限制唯一根元素
     3.脚本`script`标签中添加`setup`属性支持组合式API
   **`index.html`**: 单页入口文件，提供id为app的挂载点
3. **`setup`**: 组合式API
   执行时机比beforeCreate更早, 因此this是undefined
4. **`ref`和`reactive`**: 
   `reactive`: 接收对象类型数据的参数传入并返回响应式对象
   ```javascript
   import { reactive } from 'vue'
   const obj = reactive({ 对象类型数据 })
   ```
   `ref`: 接收简单类型或对象类型的数据传入并返回响应式对象
   本质上是将简单类型的数据转换成对象类型数据，因此要对数据进行操作时，需要使用`.value`
   ```javascript
   import { ref } from 'vue'
   const count = ref(0)
   const sunCount = () => {
      count.value++
   }
   ```
5. `computed`: 计算属性
   1.导入computed
   2.执行函数中return基于响应式数据做计算的值
   ```javascript
   import { computed, ref } from 'vue'
   const count = ref(0)
   const doubleCount = computed(() => count.value * 2)
   ```
6. `watch`: 监听数据
   ```javascript
   import { watch, ref } from 'vue'
   const count = ref(0)
   const name = ref('tom')
   const user = ref({ name: 'tom', age: 18 })
   watch(count, (newValue, oldValue) => {
      console.log(`新值为${newValue}，旧值为${oldValue}`)
   })
   //监听多个ref数据
   watch([count, name], ([newCount, newName], [oldCount, oldName]) => {
      console.log(`新值为${newCount},${newName}，旧值为${oldCount},${oldName}`)
   }, 
   { deep: true }, //深度监听
   { immediate: true } //立即执行
   )
   //监听对象中的某一个值
   watch(() => user.value.age, 
   (newValue, oldValue) => {
      console.log(`新值为${newValue}，旧值为${oldValue}`)
   }) 
   ```
7. **生命周期**
   Vue3中的生命周期函数与Vue2中的生命周期函数一致，不过命名规则不同，并且Vue3中的生命周期函数可以多次调用。
8. **组合式API下父子组件间传递数据**
   **父传子:**
   1.在父组件中在自定义标签内部
   2.在子组件中通过编译器宏接收数据
   ```html
   <!-- 父组件 -->
   <script setup>
      import { ref } from 'vue'
      import Child from './Child.vue'
      const msg = ref('hello world')
   </script>
   <template>
      <!-- 1.子组件标签内部绑定属性msg -->
      <Child :msg="msg" />
   </template>
   <!-- 子组件 -->
   <script setup>
      // 2.通过defineProps接收数据
      const props = defineProps({
         msg: String
      })
   </script>
   <template>
      <p>{{ msg }}</p>
   </template>
   ```
   **子传父:**
   ```html
   <!-- 子组件 -->
   <script setup>
      // 通过defineEmits生成emit方法
      const emit = defineEmits(['get-msg'])
      const sendMsg = () => {
         // 触发自定义事件，传递参数
         emit('get-msg', 'hello world')
      }
   </script>
   <template>
      <button @click="sendMsg">发送消息</button>
   </template>
   <!-- 父组件 -->
   <script setup>
      // 引入子组件
      import Child from './Child.vue'
      const getMsg = (msg) => {
         console.log(msg)
      }
   </script>
   <template>
      <!-- 绑定自定义事件 -->
      <Child @get-msg="getMsg" />
   </template>
   ```
9. **模板引用**
   通过ref标识符，获取组件实例，并调用组件实例的方法
   默认情况下，`<script setup>`语法糖的组件内部属性和方法是不开放给父组件访问的，可以通过`defineExpose`方法来暴露组件内部属性和方法给父组件访问。
   ```html
   <script setup>
      import { ref } from 'vue'
      const hRef = ref(null) 
      defineExpose({
         hRef  //通过defineExpose即可将hRef暴露给父组件访问
      })
   </script>
   <template>
      <!-- 获取组件实例，ref实例要和定义的变量一致 -->
      <h1 ref="hRef">Hello World</h1>
   </template>
   ```
10. **`provide`和`inject`**
    顶层组件通过`provide`方法将数据提供给子组件，底层组件通过`inject`方法获取数据。
    使用:
    关于`provide`: `provide( key, value )`
    关于`inject`: `inject(key)` 要和`provide`的key一致
11. **`defineOptions`**
    `defineOptions`用于定义组件的选项，如`name`、`components`、`props`等。
    使用: 
    ```javascript
    defineOptions({
      name: 'MyComponent',
    })
    ```
12. **`pinia`**
    `pinia` 是一个用于管理状态的库，它可以在 Vue3 中使用。
    使用: 
    1.安装：`npm install pinia@latest`
    2.挂载
    ```javascript
    import { createPinia } from 'pinia'
    import { createApp } from 'vue'
    import App from './App.vue'
    const app = createApp(App)
    cost pinia = createPinia()
    app.use(pinia)
    app.mount('#app')
    ```
    3.**创建store, action, getter**
    没有使用过的store, 是不会被创建对象的
    store是使用reactive创建的, 所以store对象是响应式的
   
    ```javascript
    import { defineStore } from 'pinia'
    import { ref } from 'vue'

    export const useCounterStore = defineStore('counter', () => {
      // 定义store
      const count = ref(0)

      // 定义action
      const increment = () => count.value++
      // 定义异步方法
      const asyncIncrement = async () => {
         const res = await fetch('https://xxxx.com/')
      }
      // 获取getter
      const double = computed(() => count.value * 2)

      return { count, increment, double }
    }, {
      // persist: true // 开启持久化
      // persist具体配置
      persist: {
         key: 'count',  // 修改本地存储的标识
         paths: ['count'] // 存储的数据
      }
    })
    ```
    4.使用store
    为了从store中获取数据并保持响应性，可以使用`storeToRefs`方法
    ```html
    <script setup>
      import { useCounterStore } from './store'
      const store = useCounterStore()
      const { count, double } = storeToRefs(store)
    </script>
    <template>
      <p>{{ store.count, store.increment, store.double }}</p>
    </template>
    ```
    5.`pinia`持久化
    安装`pinia-plugin-persistedstate`: `npm i pinia-plugin-persistedstate`
    在store中导入pinia-plugin-persistedstate
    ```javascript
    import { createApp } from 'vue'
    import { createPinia } from 'pinia'
    import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
    import App from './App.vue'
    const pinia = createPinia()
    const app = createApp(App)
    app.use(pinia.use(piniaPluginPersistedstate))
    app.mount('#app')
    ```
