### 一、Vue
1. **Vue**: 是一个用于构建用户界面的渐进式框架。
   基于数据渲染用户看到的界面。
   两种开发方式：基于核心包的局部模块改造，基于Vue工程化的整站开发
   有一套完整的项目解决方案，提升开发效率
2. **Vue对象**：
   ```javascript
   const app = new Vue({
     el: '#app', //需要控制的元素id
     data: { //提供需要渲染数据
     },
     methods: { //提供方法函数
     //methods中的this会指向Vue实例
     }
   })
   ```
### 二、插值表达式
1. **插值表达式**：`{{}}` 插值表达式，用于将数据渲染到页面中
   支持普通的变量渲染 `{{ msg }}`
   支持对象属性渲染 `{{ obj.name }}`
   支持三元表达式 `{{ obj.age > 18 ? '成年' : '未成年' }}`
   支持字符串拼接 `{{ '姓名：' + obj.name }}`
   支持方法调用 `{{ obj.getName() }}`
   不能是语句，例如if、for、while等
### 三、Vue指令
1. **v-html**：用于将数据渲染到页面中，数据会被解析为HTML，相当于innerHTML属性
2. **v-show = "表达式"**：用于控制元素是否显示，值为true时显示，值为false时隐藏
   本质上是通过控制元素的display属性来实现的，一般用于频繁切换的场景
3. **v-if = "表达式"**：用于控制元素是否显示，值为true时显示，值为false时隐藏
   本质上是通过判断条件来控制元素的创建和移除，一般用于不频繁切换的场景
   **v-else** **v-else-if**：辅助v-if使用进行判断渲染
4. **v-on: 事件名="内联语句"** / **v-on:事件名="method的函数名"**：用于监听事件，提供处理逻辑
   可以将`v-on`写成`@`
   **传参**: `v-on:click="handleClick(参数1, 参数2...)"`
5. **v-bind:属性名="内联语句"**：用于绑定属性，课简写为`:属性名="内联语句"`
6. **v-for**：用于循环渲染, 可循环渲染数组、对象、字符串...
   `v-for="(item, index) in items"`
   item: 每一项
   index: 索引(若不需要可省略)
   使用`v-for`后还需要绑定key属性：`:key="item.id"`
   **key**: `:key = "唯一标识"` 给列表项添加唯一标识，便于Vue进行列表项的正确排序复用。
   若不加key属性，Vue会默认原地修改元素，就地复用。
   不推荐用index索引作为key属性，index会变化
7. **v-model**: 双向数据绑定 
   `v-model="变量名"`
   **作用**: 给表单元素使用，可以快速获取或设置表单元素的内容
8. **指令修饰符**: 通过`.`指明一些指令后缀，不同后缀封装了不同的处理操作
   **按键修饰符:** 
   @keyup.enter  键盘回车监听
   **v-model修饰符:** 
   v-model.trim  去除前后空格
   v-model.number  将输入内容转为数字
   **事件修饰符**: 
   @事件名.stop  阻止事件冒泡
   @事件名.prevent  阻止默认事件
9. **v-bind操作class**: 
   **语法**: `class = "对象/数组"`
   **关于对象**: 键名是类名，键值是布尔值，如果值为true，则添加该类名，否则不添加。
   适用于一个类名来回切换
   `<div class="box" :class="{类名1: 布尔值, 类名2: 布尔值, ...}"> </div>`
   **关于数组**: 数组中包含的类名，则添加该类名，否则不添加。
   适用于批量添加或删除类名
   `<div class="box" :class="['类名1', '类名2', ...]"> </div>`
   **v-bind操作css**: 用于操作单个的css样式
   `<div class="box" :style="{css属性名: css属性值, css属性名: css属性值, ...}"> </div>`
10. **v-model用于其他表单元素**:
    会根据控件类型，自动选择合适的方法更新元素
    `<input type="text" v-model="变量名">`
    `<textarea v-model="变量名">`
    `<select v-model="变量名" value="选项值">`
    `<input type="checkbox" v-model="变量名" value="选项值">`
    `<input type="radio" v-model="变量名" value="选项值">`
11. **计算属性**: 基于现有的数据，计算出来的新属性。依赖数据变化，自动重新计算。
    **语法**:
    方式一: 在computed配置项中，一个计算属性对应一个函数
    `computed: { 属性名() {xxx计算逻辑; return 计算值 } }` 
    在html中访问: `{{ 属性名 }}`属性名后不加括号
    对比使用方法计算，computed计算属性会缓存，再次使用时就会直接读取缓存，提升性能，直到依赖项变化才会重新计算，然后重新缓存新值。
    关于计算属性的完整写法：
    ```javascript
    computed: { 
      计算属性名: { 
        get() { //当被获取求值时执行
          xxx计算逻辑;
          return xxx结果;
        },
        set(修改的值) {  //当计算属性被修改赋值时执行
          xxx计算逻辑;
        }
      }
    }
    ```
    方式二: 使用方法来计算，最后调用方法来获取计算结果
    `methods: { 函数名() {xxx计算逻辑; return 值 } }`
    `<div>{{ 函数名() }}</div>`
12. **watch**: 监听数据变化，执行对应的处理逻辑
    **语法**:
    简单写法: 简单数据类型，直接监视
    ```javascript
    data() { 
      word: 'xxx',
      obj: {
         word: 'xxx'
       }
    },
    watch: { 
      数据属性名(newValue, oldValue) { //newValue: 新值，oldValue: 旧值
        xxx处理逻辑;
      },
      '对象.属性名'(newValue, oldValue) { //newValue: 新值，oldValue: 旧值
        xxx处理逻辑;
      }
    }
    ```
    完整写法：添加额外配置项
    `deep: true`, 对复杂类型深度监视
    `immediate: true`, 初始化后立刻执行一次handler方法
    ```javascript
    watch: {
      data属性名: {
         deep: true,
         immediate: true,
         handler(newValue, oldValue) { //newValue: 新值，oldValue: 旧值
         xxx处理逻辑;
         }
      }
    }
    ```
### 四、生命周期
1. **Vue的生命周期:** Vue实例从创建到销毁的过程。
   **创建阶段**: 响应式数据
   **挂载阶段**: 渲染模板
   **更新阶段**: 数据变化，重新渲染模板
   **销毁阶段**: 销毁实例
2. **生命周期函数**: Vue实例创建、挂载、更新、销毁时，会执行对应的生命周期函数。
   被称为生命周期钩子，可以让开发者在特定阶段运行对应的代码。
   一般在created中发送初始化渲染请求：
   ```javascript
   async created() {
      const res = await axios.get('xxx');
      this.list = res.data;
    }
   ```
   在mounted中操作dom。
   ```javascript
   //搜索框渲染完成后立刻获得焦点
   mounted() {
      this.$refs.search.focus();
   }
   ```
   在beforeDestroy中销毁实例。
###　五、工程化Vue项目
1. **Vue项目创建**: 
   全局安装: `npm install -g @vue/cli` (只需操作一次)
   查看版本: `vue -V`
   创建项目: `vue create 项目名(不能中文)`
   启动项目: `npm run serve`
2. **Vue项目结构**: 
   * **node_modules**: 第三方文件夹
   * **public**: 存放html文件
     favicon.ico: 网站图标 
     index.html: 模板文件
   * **src**: 源代码目录
     assets: 静态资源文件夹: 图片、字体、样式文件
     components: 组件文件夹: 通用组件
     App.vue: 根组件, 项目中运行看到的内容
     main.js: 项目入口文件，打包或运行第一个执行的文件
   * **.gitignore**: git忽略文件
   * **babel.config.js**: babel配置文件
   * **jsconfig.js**: js配置文件
   * **package.json**: 项目依赖包版本信息 (包含项目名、版本号、scripts、依赖包)
   * **README.md**: 项目说明文件
   * **vue-config.js**: vue配置文件
   * **package-lock.json**: 项目依赖包版本信息, 锁定安装版本
### 五、组件化开发
1. **组件化开发**: 组件化开发，将页面拆分为多个组件，每个组件是一个独立的功能块，组件之间可以进行数据传递。
   便于维护，利于复用
2. **App.vue组成**:
   **`<template>`**: 结构(Vue2有且只有一个根标签)
   **`<style>`**: 样式, 支持less, 使用less时要安装:`npm i less less-loader -D`
   若要其只作用于当前组件, 则在style标签中添加scoped属性
   `scoped`会通过给当前组件添加`data-v-dash`值得属性，从而实现样式的隔离
   **行为逻辑:** 
   el是根实例独有，data是一个函数，其他配置项一致
   ```javascript
   export default {
      methods: {
         //逻辑
      }
   }
   ```
3. **组件注册**:
   * **局部注册**:
     创建.vue文件；
     在使用的组件内导入并注册：
     ```javascript
     import 组件对象 from '.vue的文件路径'
     export default {
       components: {
         //局部注册
         '组件名': 组件对象,
       }
     }
     ```
   * **全局注册**:
     创建.vue文件；
     在main.js中导入并注册：
     ```javascript
     import 组件对象 from '.vue的文件路径'
     Vue.component('组件名', 组件对象)
     ```
     所有组件内都能使用
   * **组件使用**:
     当成html来使用`<组件名>`
     组件的命名规范: 大驼峰命名
4. **data函数**：
   data函数会保证每个组件实例是独立的，不会相互干扰
   ```javascript
   data() {
      return {
         data: '数据'
      }
   }
   ```
5. **组件通信**:
   **组件之间的关系**: 
   父子关系: props 和 $emit
   非父子关系: provide / inject / eventbus
   通用解决方案: vuex
   **props**: 父组件向子组件传递数据
   **$emit**: 子组件发送事件给父组件
   ```html
   <!-- 父组件 -->
   <!-- 结构部分 -->
   <!-- 父向子传递数据时，需要绑定属性，子修改父的数据时需要监听事件 -->
   <Child :title="title" @changeTitle="handleChange"></Child>
   <!-- 逻辑部分 -->
   <script>
      import Child from './Child.vue'
      export default {
         data() {
            return {
               title: 'hello world', // 父组件的数据
            }
         },
         methods: { // 提供处理函数用于处理子组件发送的事件
            handleChange(newTitle) {
               this.title = newTitle
            }
         },
         components: {
            Child,
         }
      }
   </script>
   <!-- 子组件 -->
   <!-- 结构部分 -->
   <template>
     <div>{{ title }}</div>
     <button @click="changeTitle">修改title</button>
   </template>
   <!-- 逻辑部分 -->
   <script>
   export default {
      //通过props接收父组件传递的title
      props: ['title'], //若要传递多个参数，使用逗号隔开
      methods: {
         changeTitle() {
            //通过$emit向父组件发送事件
            this.$emit('changeTitle', 'new title')
         }
      }
   }
   </script>
   ```
   **关于props校验**:
   `props: { 校验的属性名: 指定数据类型 }`
   完整写法：
   ```javascript
   props: {
      校验的属性名: {
         type: 指定数据类型,
         required: 是否必填, //(true/false)
         default: 默认值,
         validator(value){ //自定义校验函数
            return 是否通过校验;
         }  
      }
   }
   ```
   **关于prop和data**:
   共同点：都可以给组件提供数据
   不同点：prop数据时外部的，需要修改时要遵循单向数据流的原则，由子组件向父组件传递修改事件，而data数据时内部的，可以任意修改。
   单项数据流：父级prop的数据更新会向下流动，影响到子组件，并且该流向是单向的。
   原则: 谁的数据谁负责
   
   
   
