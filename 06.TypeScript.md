### 一、TypeScript
1. **TypeScript** 是 JavaScript 的超集，TypeScript 允许在 JavaScript 的基础上添加类型检查。
2. **安装**：
   推荐使用18.20.8版本nodeJS
```bash
# 安装 TypeScript 及运行工具
npm install -D typescript ts-node @types/node
# 可选：安装现代替代工具（推荐）
npm install -D tsx
# tsconfig.json (TypeScript 编译配置)
npx tsc --init
```
修改生成的 tsconfig.json：
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "esModuleInterop": true,
    "strict": true,
    "outDir": "./dist"
  }
}
```
package.json (项目配置)
```json
{
  "type": "commonjs",
  "scripts": {
    "start": "ts-node src/index.ts",
    "build": "tsc",
    "dev": "tsx watch src/index.ts"
  },
  "devDependencies": {
    "@types/node": "^20.x",
    "ts-node": "^10.9.2",
    "typescript": "^5.x",
    "tsx": "^4.7.0"
  }
}
```
```bash
# 运行
ts-node 01-hello.ts
```
### 二、类型注解
`let myName: string = 'Tom';`
代码中`: string` 就是类型注解，表示变量 myName 的类型是 string。
1. **JS已有类型：** 
   原始类型：
   `let name: string = 'TOM'`
   `let number: number = 18` 
   `let boolean: boolean = true` 
   `let n: null = null` 
   `let a: undefined = undefined` 
   `let s: symbol = Symbol('key')` 
   对象类型：
   `let obj: object = {name: 'Tom', age: 18}`
   `let arr: number[] = [1, 2, 3]`
   `let arr2: Array<string> = ['1', 'Tom', 'man']`
2. **TS新增类型：** 
   **联合类型:**
   `let arr: (number | string)[] = [1, 'Tom', 18]`若不加括号，则只能是number或者string数组类型
 字面量类型、枚举、void、any等。
  **类型别名:** 使用`type`关键字定义类型别名。
  `type Name = (string | number)[];`
  `let name: Name = ['Tom', 18];`
1. **函数类型:**
   **单独指定函数参数/返回值类型:**
   `function add(x: number, y: number): number { return x + y }`
   `const add = (x: number, y: number): number => x + y;`
   **同时指定函数参数/返回值类型:** 只适用于函数表达式 
   `const add: (x: number, y: number) => number = (x, y) => x + y;`
   **void类型**: 表示函数返回值为空
   `function print(): void { console.log('hello world') }`
   **可选参数**: 使用`?`表示可选参数
   `function add(x?: number, y?: number): number { console.log(x, y) }`
   **对象类型**: 使用`{}`定义对象类型
   `let obj: { name: string, age: number, sayHi():void } = { name: 'Tom', age: 18, sayHi() { console.log('hello world')} };`
   **对象可选属性：** 使用`?`表示可选属性
   `let obj: { name: string, age?: number, sayHi():void } = { name: 'Tom', sayHi() { console.log('hello world')} };`
2. **接口**：当一个对象类型被使用多次，就可以使用接口来定义对象类型。达到复用的目的
   `interface Person { name: string, age: number }`
   `let tom: Person = { name: 'Tom', age: 18 }`
   **类型别名(type)和接口(interface)区别**：
   **相同点：** 类型别名和接口都可以定义对象类型。
   **不同点：** 接口只能为对象指定类型，类型别名不仅为对象指定类型，还可为任意类型指定别名。
   **接口继承**: 如果有两个接口有相同的属性和方法，那么可以将公共部分抽离出来，通过继承实现复用。
   `interface Person { name: string; age: number; }`
   `interface Teacher extends Person { teach(): void; }`
3. **元组(Tuple)**: 是一种特殊的数组，它确切知道包含多少元素，以及特定索引对应的类型。
   例如定义经纬度: `let position: [number, number] = [10.0, 20.0];`
4. **类型推论**: TypeScript会根据赋值给变量的值来推论变量的类型。
   当声明变量未初始化时，或者决定函数返回值时，会触发类型推论。
5. **类型断言**: 允许我们手动指定一个变量的类型。通过断言，可以让变量类型变得更具体，可以访问某些标签特有的属性。
例如：`const aLink = document.getElementById('link') as HTMLAnchorElement;`
还可以写成`const aLink = <HTMLAnchorElement>document.getElementById('link');`(不常用)
此时便可以访问到`aLink.href`属性。
6. **字面量类型**: 字面量类型一般配合联合类型一起使用，用来表示一组明确可选值的列表。
   例如：`type Direction = 'up' | 'down' | 'left' | 'right';`
   对比string类型，字面量类型可以更精确地描述变量的值。
7. **枚举**: 枚举类型用于定义一组命名的常量，类似于字面量+联合类型的组合功能，表示一组明确可选值
   `enum Direction { Up, Down, Left, Right }`
   需要使用时需加上枚举名，如`Direction.Up`
   枚举是有值的，默认从0开始自增，上面例子中Up = 0，Down = 1，Left = 2，Right = 3。
   也可以自定义枚举值，如`enum Direction { Up = 10, Down, Left, Right }`;
   这种枚举称之为数字枚举。
   枚举也可以是字符串枚举，如`enum Direction { Up = "Up", Down = "Down", Left = "Left", Right = "Right" }`;
   此时字符串的枚举都要有初始值;
   在编译为JS时，枚举类型会被编译为JS代码，而其他类型则会被移除。
   **一般情况下，推荐使用字面量类型+联合类型组合的方式，比直接用枚举更直观。**
8. **any类型**: any类型表示任意类型，可以对值进行任意操作，不会有代码提示，一般不推荐使用。
   当声明变量时不提供类型，不提供默认值，函数参数不加类型时，隐式会具有any类型。
9. **typeof运算符**: 
    JS中可以使用typeof运算符获取变量的类型，比如`typeof 1`;
    TS中也提供了typeof运算符，可在类型上下文中查询变量类型
```typescript
let p = { x: 0, y: 0 };
function printCoord(point: typeof p) {}
printCoord({ x: 100, y: 100 }); // OK
```
### 三、高级类型
1. **class类型**: 
   `class Person {}; const p = new Person();`; 
   根据类型推论，p类型为Person;
   TypeScript的class不仅提供了class的语法，也作为一种类型存在。
2. **class构造函数**:
```typescript
class Person {
  age: number;
  gender: string;
  constructor(age: number, gender: string) {
    this.age = age;
    this.gender = gender;
  }
}
```
3. **实例方法**:
```typescript
class Person {
  x = 1;
  y = 2;
  add(a: number) {
    this.x += a;
    this.y += a;
  }
}
```
4. **类的继承**:
   类继承的两种方法： 
   `extends` 关键字(继承父类):
```typescript
class Person {
  move() {
    console.log('move');
  }
}
class Student extends Person {
  study() {
    console.log('study');
  }
}
const s = new Student();
s.move();
s.study();
```
`implements` 关键字(实现接口):
```typescript
interface Person {
  move(): void;
}
class Student implements Person { // 实现接口,必须要实现接口中的所有方法和属性
  move() {
    console.log('move');
  }
}
```
5. **修饰符**: 
   可见修饰符有：
   `public(共有的，默认，可省略)`, 可以被任何地方访问。 
   `private(私有的)`, 只在当前类中可见, 对子类和实例对象也不可见。
   `protected(受保护的)`, 仅对其声明所在类和子类中(非实例对象)可见，
   子类内部可以通过this来访问父类中受保护的成员，但是，对实例不可见。
   `readonly(只读的)`, 防止在构造函数之外对属性赋值，只修饰属性，不能修饰方法。
   readonly修饰的属性，必须手动提供明确的类型。
   在类中，`readonly`只能在构造函数中赋值，不能在类外赋值。在接口或{}中，`readonly`表示只读。
### 四、类型兼容性
1. **对象类型兼容性**:  
   对于对象类型，若y对象中的成员至少与x相同，则x兼容y(成员多的可以赋值给少的)。
```typeScript
class x { a: number; b: number;}   
class y { a: number; b: number; c: number;}
const p: x = new y(); // p兼容y
const q: y = new x(); // 若反过来，则q不兼容x
```
2. **接口类型兼容性**: 接口类型的兼容性与对象类型兼容性基本一致。
3. **函数兼容性**: 函数的兼容性主要考虑参数个数、参数类型、返回值类型。
   **对于参数个数：** 参数多的会兼容参数少的，参数少的可以赋值给参数多的。
```typescript
type F1 = (a: number, b: number) => void;
type F2 = (a: number) => void;
let f1: F1;
let f2: F2;
f1 = f2;
f2 = f1; // 错误
```
   **对于参数类型：** 相同位置的参数类型要相同或兼容。
```typescript
type F1 = (a: number) => string;
type F2 = (a: string) => string;
let f1: F1;
let f2: F2;
f1 = f2;
f2 = f1; //均正确
```
  **当参数类型为对象时：** 需要将对象的属性看成一个个参数，参数少的赋值给参数多的。
```typescript
interface print1 { name: string; age: number;}
interface print2 { name: string; age: number; sex: string;}
type F1 = (a: print1) => string;
type F2 = (a: print2) => string;
let f1: F1;
let f2: F2;
f1 = f2; //错误
f2 = f1; //正确
```
  **对于返回值类型：** 
  如果返回值时原始类型，那么此时返回值类型必须一致。
```typescript
type F1 = () => string;
type F2 = () => string; //类型相同，兼容
let f1: F1;
let f2: F2;
f1 = f2; //正确
```
  如果返回值类型为对象，那么此时成员少的可以赋值给成员多的。
```typescript
type F1 = () => { name: string; age: number; sex: string;};
type F2 = () => { name: string; age: number;};
let f1: F1;
let f2: F2;
f1 = f2; //正确
f2 = f1; //错误
``` 
### 五、交叉类型
1. **交叉类型**: 是将多个类型合并为一个类型。
```typescript
interface Person {
  name: string;
}
interface Age {
  age: number;
}
type PersonAge = Person & Age;
let personAge: PersonAge = {
  name: '张三',
  age: 18
}
``` 
2. **交叉类型和接口对比**: 
   相同点：都可以实现对象类型的组合
   不同点：两种方式实现类型组合时，对于同名属性间，处理类型冲突的方式不同
### 六、泛型
1. **泛型**: 保证类型安全的前提下，让函数等多种类型一起工作，实现复用。
   `function id<Type>(value: Type): Type { return value; }`
   **函数调用：** 能省则省，若编译器推断不出类型，则显式传入参数。
   `id<string>('abc')`可简化成为`id('abc')`
2. **泛型约束**: 由于Type的类型过于宽泛，无法保证其包含的属性，所以要添加约束来收缩泛型的范围。
   **添加具体的类型：**
   `function id<Type>(value: Type[]): Type { return value.length; }`
   **添加约束：**
   `interface Lengthwise { length: number; }`
   `function id<Type extends LengthWise>(value: Type): Type { return value.length; }`
   **泛型类型变量可以有多个，并且类型变量之间还可以约束：(第二个类型变量受第一个类型变量约束)**
   keyof 指接收一个对象类型，生成其键的名称(字符串或数字)的联合类型
   key受到Type约束，Key只能是Type中所有键的其中一个
```typescript
 function getGroup<T, K extends keyof T>(obj: T, key: K) { //keyof T 表示'name' | 'age'
   return obj[key]; 
   }
   let person = { name: 'Tom', age: 35 };
   getGroup(person, 'name');
```

