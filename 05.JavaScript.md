### 一、JavaScript组成

* **ECMAScript**: JavaScript语言本身, 规定了JavaScript的基础语法。
* **DOM**: Document Object Model, 操作文档。对页面的内容进行，移动，大小，添加，删除操作。
* **BOM**: Browser Object Model, 操作浏览器。例如页面弹窗，存储数据等。

### 二、JavaScript书写位置
* **1.内部JS**
  内部JS书写在HTML文档中，最好在HTML文档的body标签底部，写在其他HTMl标签的外面，写在script标签内部。
* **2.外部JS**
  写在以.js结尾的文件中，然后引入HTML文档中：
  `<script src="xxx.js"></script>`
### 三、JavaScript输出语句
* **1.`document.write()`** 向HTML文档中写入内容
* **2.`alert()`** 弹出警告框
* **3.`console.log()`** 向浏览器的控制台写入内容
### 四、JavaScript输入语句
* **1.`prompt()`** 弹出输入框，括号中可写相应的提示信息
### 五、变量
* **1.声明变量：**
  `let 变量名;` let不允许重复声明一个变量，变量是程序在内存中申请的一块存放数据的空间。
* **2.数组：**
  `let 数组名 = [数据1, 数据2, 数据3, ...];`
### 六、常量
* **1.声明常量：** 
  `const 符号 = 值;`
  const声明的常量不能被重新赋值。
  声明常量时必须赋值(初始化)，否则会报错。
### 七、数据类型
* **1.基本数据类型：**
  **Number**: 数值类型 其中`NaN`表示一种运算错误，无论进行什么操作，返回的都是`NaN`。
  **String**: 字符串类型 只要是单引号、双引号、反引号包裹的都是字符串
  其中，反引号包裹的是模板字符串，它内部可以使用`${}`来引用变量。
  **Boolean**: 布尔类型
  **Null**: 空值类型，表示赋值了，但值是空的。
  **Undefined**: 未定义类型，表示根本没有被赋值。
* **2.引用数据类型：**
  **Object**: 对象类型
* **3.利用typeof判断数据类型**
  `typeof x;`
* **4.类型转换**
  **隐式转换**：
  当+两边有一个是字符串，都会把另一个值也转成字符串
  +可以将数值转换成字符串，其他的算数运算符也能做到
  **显式转换**：
  `Number()`：将任意值转换成数字，若有非数字的字符串，则返回NaN
  `parseInt()`：将字符串转换成数字,只保留整数
  `parseFloat()`：将字符串转换成数字，保留小数
* **比较运算符**：
  `==`：比较两个值是否相等
  `===`：比较两个值是否相等，并且类型也相等
### 八、数组操作----新增数组
* **`数组名.push('xxx', xxx, ...)`**: 向数组的末尾添加一个或多个元素，并返回新的长度。
* **`数组名.unshift('xxx', xxx, ...)`**: 向数组的开头添加一个或多个元素，并返回新的长度。
### 九、数组操作----删除数组
* **`数组名.pop()`**: 删除数组的最后一个元素
* **`数组名.shift()`**: 删除数组的第一个元素
* **`数组名.splice(start, deleteCount, item1, item2, ...)`**: 删除数组的指定位置的元素，start: 开始位置，deleteCount: 删除的个数，item1, item2, ...: 新的元素。
### 十、函数
* **`function 函数名(参数1, 参数2, ...) { 函数体 }`**: 定义一个函数
* **匿名函数**: `function(参数1, 参数2, ...) { 函数体 }`
  **立即执行函数**: `(function(参数1, 参数2, ...) { 函数体 })();`
### 十一、对象
* **对象**: `let 对象名 = { 属性1: 值1, 属性2: 值2, ... }`或者`let 对象名 = new Object()`
* **查看对象**: `对象名.属性名`或者`对象名['属性名']`
* **修改对象**: `对象名.属性名 = 新值`
* **增加属性**: `对象名.属性名 = 值`
* **删除属性**: `delete 对象名.属性名`
* **对象的方法**: `let 对象名 = { 方法1: function(参数1, 参数2, ...) { 函数体 }, 方法2: function(参数1, 参数2, ...) { 函数体 }, ... }`
调用时: `对象名.方法名(参数1, 参数2, ...)`
* **对象属性的遍历**: `for (let 任意属性名 in 对象名) { 对象名['任意属性名'] }` 
* **内置对象**:
  * `Math`: 数学对象
   `random()`: 随机数, 返回一个0-1之间，包括0但不包括1的随机小数，若要获取0-n之间(不包含n)的随机整数，则需要使用`Math.floor(Math.random() * n)`
   生成n~m之间的随机数: `Math.floor(Math.random() * (m - n + 1)) + n`
   `ceil()`: 向上取整
   `floor()`: 向下取整
   `max()`: 最大值
   `min()`: 最小值
   `pow()`: 幂运算
   `abs()`: 绝对值
   `round()`: 四舍五入
### 十二、DOM
1. **匹配第一个元素**: `let 变量名 = document.querySelector('选择器')`
2. **匹配所有元素**: `let 变量名 = document.querySelectorAll('选择器')`
   返回一个NodeList对象集合，这是一个有长度有索引的伪数组，没有pop()等方法。只能通过for循环遍历得到元素。
3. **修改标签内容**: 
   `变量名.innerText = '内容'` 纯文本，不解析标签
   `变量名.innerHTML = '内容'` 会解析标签
4. **修改CSS样式**: `变量名.style.属性 = '值'`
5. **通过ClassList控制元素**: 
   添加类：`变量名.classList.add('className')`
   删除类：`变量名.classList.remove('className')`
   切换类：`变量名.classList.toggle('className')`
6. **操作表单**:
   获取表单值：`变量名.value`
   设置表单值：`变量名.value = '值'`
   选择框选中：`变量名.checked = true`
   禁用按钮：`变量名.disabled = true`
7. **自定义属性**: 
   html5中的自定义属性：`data-属性名="属性值"`
   获取属性值：`变量名.dataset.属性名`
8. **定时器-间歇函数**:
   `let 变量名 = setInterval(function() { 函数体 }, 时间间隔)`;
   或者在外部定义函数: `function 函数名() { 函数体 }`再调用: `let 变量名 = setInterval(函数名, 时间间隔)`此时这里的函数名不加小括号;
   关闭定时器：`clearInterval(变量名)`
9. **事件监听**: 
  * **事件监听三要素：**
    **事件源**：要监听的元素对象，获取dom元素
    **事件类型：**
    常用的鼠标事件：鼠标点击(click)、鼠标移入(mouseover)、鼠标离开(mouseleave)
    表单获得光标: 获得焦点(focus)、失去焦点(blur)
    键盘触发事件：按键按下(keydown)、按键抬起(keyup) 
    表单输入触发: 输入完成(input)
    **事件处理函数：** 当事件发生时，要执行的函数
  * **添加事件监听**：`元素对象.addEventListener('事件名', function() { 函数体 })`
  早期写法：`元素对象.on事件名 = function() { 函数体 }`
   区别：on事件名的方式会被覆盖，addEventListener会绑定多次，有更多事件特征
10. **事件对象**: 可以判断鼠标位置和键盘按键
    **事件对象属性**: 
    `event.clientX/clientY`: 鼠标相对于浏览器窗口左上角的位置
    `event.offsetX/offsetY`: 鼠标相对于当前DOM元素左上角位置
    `event.key`: 键盘按键上的值
    `event.type`: 获取事件类型
11. **环境对象**:
    指的是函数内部特殊变量this，当前函数运行所处的环境
    谁调用，this就指向谁
    之前直接调用函数，相当于`window.函数名`，这里this指向window
    **回调函数**：函数A作为参数传递给函数B，函数A就称为回调函数
12. **事件流**: 浏览器从DOM元素触发事件，会按照事件捕获->目标元素->事件冒泡执行事件处理函数
    **事件捕获**: 从DOM的根元素开始，去执行对应的事件(从外到里)
    `DOM.addEventListener('事件名', function() { 函数体 }, true)`
    第三个参数为true时，表示事件捕获时触发，默认是false，表示事件冒泡时触发
    **事件冒泡**: 当元素触发事件时，会依次向上调用所有父级元素的同名事件。
    **阻止事件冒泡**: `event.stopPropagation()` 把事件限制在当前元素
    关于鼠标经过事件：`mouseover`和`mouseout`事件有冒泡效果，`mouseenter`和`mouseleave`事件没有冒泡效果
    **事件解绑**: 
    早期写法：`元素对象.on事件名 = null`
    新写法：`元素对象.removeEventListener('事件名', function() { 函数体 })`
    匿名函数无法被解绑
    **事件委托**: 给父级元素注册事件，当触发子元素时，会冒泡到父级元素，然后执行父级元素的事件处理函数
    **阻止元素默认行为**: `event.preventDefault()`
13. **页面加载事件**: 
    `load`: 外部资源加载完毕时触发
    `window.addEventListener('load', function() { 函数体 })`
    `DOMContentLoaded`: 当初始的HTML页面被加载解析完成后，DOMContentLoaded事件触发，无需等待图片、样式表等资源加载完毕
    `document.addEventListener('DOMContentLoaded', function() { 函数体 })`
    **页面滚动事件**: 
    `scroll`: 滚动条滚动时触发(通常用于window对象或document对象)
    `window.addEventListener('scroll', function() { 函数体 })`
    `scrollTop`: 元素向上滚动看不到的距离
    `scrollLeft`: 元素水平滚动看不到的距离
14. **屏幕尺寸事件**:
    `resize`: 浏览器窗口大小改变时触发
    `window.addEventListener('resize', function() { 函数体 })`
    **获取屏幕尺寸**:
    `clientWidth`: 浏览器窗口可见宽度
    `clientHeight`: 浏览器窗口可见高度
    **元素宽高**: 获取的是可视区宽高，若隐藏，则值为0
    `offsetWidth`: 元素宽度
    `offsetHeight`: 元素高度
    **元素位置**: 只读，不能赋值，距离自己最近的带定位的父级元素的左、上边距离
    `offsetLeft`: 元素左边到可视区左边的距离
    `offsetTop`: 元素上边到可视区上边的距离
    另外，还有`element.getBoundingClientRect()`方法，返回元素的大小以及相对于视口的位置
15. **日期对象**: 
    **实例化日期对象**: `const date = new Date()`, 带new关键字的代码叫做实例化
    若需要指定事件，则在括号中添加`'xxxx-xx-xx'`的字符串即可
    **日期对象的方法**: 
    `getFullYear()`: 获取年份，四位年份
    `getMonth()`: 获取月份，0-11
    `getDate()`: 获取日期，不同月份取值不同
    `getDay()`: 获取星期几，0-6
    `getHours()`: 获取小时，0-23
    `getMinutes()`: 获取分钟，0-59
    `getSeconds()`: 获取秒，0-59
    **时间戳**: 1970年1月1日0时0分0秒到当前时间点的毫秒数
    **获取时间戳:** `Date.now()`、`date.getTime()`、`+new Date()`
    其中`Date.now()`只能获取当前的时间戳
    时分秒转换为时间戳: 
    `天数 = parseInt(秒数 / 60 / 60 / 24);`
    `小时 = parseInt(秒数 / 60 / 60 % 24);`
    `分钟 = parseInt(秒数 / 60 % 60);`
    `秒数 = parseInt(秒数 % 60);`
16. **查找DOM节点:**
    **父节点查找:** `子元素.parentNode` 返回最近一级的父节点，找不到返回null
    **子节点查找:** `父元素.childNodes` 返回所有子节点，包含文本节点和注释节点
    或者使用 `父元素.children` 获取所有子元素节点，返回的是一个伪数组
    **兄弟节点查找:** `元素.previousElementSibling` 返回前一个兄弟节点，找不到返回null
    `元素.nextElementSibling` 获取后一个兄弟节点，找不到返回null
17. **创建DOM节点:** `document.createElement('标签名')` 创建一个标签元素
    **追加节点:** `父元素.appendChild(要插入的元素)` 添加子元素，插入到父元素的最后
    **插入节点:** `父元素.insertBefore(要插入的元素, 在哪个元素之前)` 插入到旧元素之前
    **克隆节点:** `元素.cloneNode(true)` 
    复制元素，参数true表示复制所有子元素
    若参数false则只复制元素本身，不包含后代结点，默认为false
    **删除节点:** `元素.removeChild(要删除的元素)` 删除元素
    若不存在父子关系则删除不成功
18. **M端事件:**
    **触屏事件:** 
    `touchstart` 手指触摸到DOM元素触发
    `touchmove` 手指在DOM元素上滑动触发
    `touchend`  手指离开DOM元素触发
### 十三、BOM
1. **BOM:** 浏览器对象模型
2. **window对象:**
   windows对象是全局对象，所有对象都继承自window对象
   document/alert()/console.log()都是window对象属性，基本BOM的属性方法也都是window的
   所有var声明的变量、函数都是window对象的属性和方法
   window对象下的属性和方法调用可以省略window对象
3. **定时器-延时函数:**
   `let timer = setTimeout(function,time)`: 延迟time毫秒后执行function
   只运行一次，把一段代码延时运行，省略window对象
   清除延时函数: `clearTimeout(timer)`
   与间歇函数的区别是，间歇函数会重复执行(除非手动清除)，而延时函数只执行一次
4. **同步任务：** 浏览器会按照代码的顺序执行，遇到异步任务就暂停，等异步任务完成后再继续执行。
5. **异步任务：** JS的异步是通过回调函数实现
   **异步任务类型：**
   定时器: setTimeout(function,time)、setInterval(function,time)
   普通事件: onclick、onmouseover、onload
   资源加载：load、error
   异步任务相关添加到任务队列中
  **JS的执行机制：**
  先执行执行栈的同步任务;
  遇到异步任务，将异步任务添加到任务队列中;
  当执行栈中的同步任务执行完毕后，会去任务队列中按顺序获取异步任务执行
  主线程不断的重复获得任务、执行任务、再获取任务、再执行。这种机制称之为事件循环(Event Loop)
6. **location对象:** location的数据类型是对象，保存了当前页面的URL的各个组成部分
   **常用属性：** 
    `href`: 获取完整的URL地址，对其赋值时用于地址的跳转
    `search`: 获取URL中?之后的参数部分
    `hash`: 获取URL中#之后的部分
    `reload()`: 重新加载当前页面, 值为true时强制刷新
7. **navigator对象:** navigator对象保存了浏览器的信息，比如浏览器的类型、版本、语言、Cookie是否启用、操作系统类型、屏幕分辨率等
8. **history对象:** history对象保存了用户上网的历史记录，可以利用它进行前进、后退、刷新等操作
   **常用方法：** 
   `go(参数)`: 用来跳转到指定页面，参数为1时跳转到历史记录中的前一个页面，为-1时跳转到历史记录中的后一个页面
   `back()`: 用来返回上一页
   `forward()`: 用来跳转到下一页
9. **localStorage对象:** localStorage对象用于保存用户数据，数据保存在浏览器中，用户关闭浏览器后数据依然保存，以key-value形式保存，数据类型为字符串。
    `localStorage.setItem('key','value')`: 用来设置localStorage对象中的数据 
    `localStorage.getItem('key')`: 用来获取localStorage对象中的数据
    `localStorage.removeItem('key')`: 用来删除localStorage对象中的数据 
    本地存储只能存储字符串类型数据
10. **sessionStorage:** sessionStorage对象存储的数据会持久到页面会话结束。用法和localStorage一样
11. **本地存储储存复杂数据:** 
    `JSON.stringify()` 当有复杂类型的数据时，可以使用该方法将数据转为JSON字符串保存在localStorage中
    `JSON.parse()` 当从localStorage中取出数据时，可以使用该方法将JSON字符串转为对象
12. **数组的map和join方法:**
    map方法：map方法会遍历数组处理数据，并返回新数组。
    `const arr = [1, 2, 3, 4, 5];`
    `const newArr = arr.map(item => item * 2);`最终的newArr为[2, 4, 6, 8, 10]
    join方法：join方法会遍历数组，将数组中的元素连接成字符串。
    `const arr = [1, 2, 3, 4, 5];`
    `const str = arr.join('-');`最终的str为'1-2-3-4-5'
13. **正则表达式:**
    **语法：**
     定义正则表达式： `const reg = /正则表达式/`
     查看正则表达式与指定字符串是否匹配： `reg.test(str)`
     查找符合规则的字符串: `str.exec(reg)`
    **元字符：**
    边界符：
     `^`: 匹配字符串的开头  
     `$`: 匹配字符串的结尾  
    量词：
    `*`: 重复0次或多次字符  
    `+`: 重复1次或多次字符  
    `?`: 匹配0次或1次字符  
    `{n}`: 重复n次字符  
    `{n,}`: 重复n次或多次字符  
    `{n,m}`: 重复n到m次字符(逗号之间不能有空格)  
    匹配字符：
    `[abc]`: 匹配abc中的任意字符，三选一
    `[^abc]`: 匹配除abc之外的任意字符
    `[a-z]`: 匹配a到z中的任意一个字符
    `[a-zA-Z]`: 匹配小写a到z和大写A到Z中的任意一个字符
    预定义：某些常见模式的简写方式
    `\d`: 匹配数字0-9
    `\D`: 匹配0-9之外的字符
    `\w`: 匹配字母、数字和下划线
    `\W`: 匹配非字母、数字和下划线
    `\s`: 匹配空白字符
    `\S`: 匹配非空白字符
    修饰符：
    `g`: 全局匹配，匹配所有符合条件的字符
    `i`: 忽略大小写
    替换：`.replace(匹配模式,替换字符串)`
### 十四、进阶
1. **作用域：**
  * **局部作用域：**
    **函数作用域：** 
    函数内部定义的变量，只在函数内部有效
    不同函数内部的变量无法相互访问
    函数执行完毕后，函数内部的变量实际上被清空了
    **块作用域：**
    块作用域是在{}内定义的变量，代码块内部声明的变量在变量外部有可能无法访问
    let 和 const 定义的变量会产生块作用域，var不会产生块作用域
    不同代码块之间的变量无法相互访问
  * **全局作用域：**
    `<script>`标签或.js文件的最外层就是全局作用域，在此声明的变量在函数内部也可以被访问。
    为window对象添加属性默认时全局的。
    函数中未使用任何关键字声明的变量为全局变量。
    尽可能少的声明全局变量，防止全局变量污染。
  * **作用域链：**
    本质上是变量查找机制
    函数执行时，优先查找当前函数作用域中的变量
    如果找不到，则会依次逐级查找父级作用域直到全局作用域
    嵌套关系的作用域串联起来形成了作用域链
    相同作用域链中按从小到大的规则查找变量
    子作用域可访问父作用域，但父作用域不可访问子作用域
2. **垃圾回收机制:**
  * **内存的生命周期：**
    内存分配：声明变量、函数、对象时，系统会自动为它们分配内存
    内存使用：使用变量、函数
    内存回收：不再使用的变量、函数、对象会自动回收
    其中，全局变量只会在页面关闭时回收
    一般情况下，局部变量的值不用会被自动回收掉
  * **内存泄漏：** 程序中分配的内存由于某种原因程序未释放或无法释放。
  * **垃圾回收机制：**
   栈: 由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型放到栈里面。
   堆: 由程序员分配释放，若程序员不释放，则由垃圾回收机制回收，复杂数据类型放进堆中。
   **引用计数：** IE定义的引用计数算法，定义"内存不再使用"，就是看一个对象是否有指向它的引用，没有就回收对象。
   1.跟踪被引用的次数
   2.对象被引用了一次，那么记录次数1，多次引用就累计次数。
   3.当对象减少一次引用就减一。
   4.如果引用次数是0，则释放内存
   **缺点：** 当两个对象互相引用，尽管已经不再使用，但它们的引用次数不是零，垃圾回收器也不会回收，造成内存泄漏
  * **标记清除法：**
   标记清除法将"不再使用的对象"定义为"无法到达的对象"。
   从根部(JS全局对象)出发定时扫描内存中的对象。凡是能够从根部到达的对象，都是"使用中的对象"。
   无法从根部出发触及到的对象被标记为不再使用，随后进行回收。
3. **闭包：**
   闭包 = 内层函数 + 引用外层函数的变量
   **作用：** 
   封闭数据，实现数据私有，外部可以访问内部的变量。
   它允许将函数与其所操作的某些数据环境关联。
   **注意：** 闭包会形成循环引用，导致内存泄漏。
```javascript 
function outer() {
  let a = 1;
  function inner() {
    console.log(a);
  }
  return inner;
}
let fn = outer();
fn();
```
4. **变量提升：** 仅针对 var 声明的变量
   在函数作用域内，var 变量会被提升到函数顶部，但赋值不会被提升。
   变量在var声明前被访问，变量值为undefined。
   变量提升出现在相同一个作用域内。
   **函数提升：** 函数声明会被提升到作用域顶部，但函数调用不会被提升。
   函数提升会使函数声明调用更灵活
   函数表达式不会出现提升
5. **动态参数：** 函数参数可以有默认值，函数调用时可以不提供参数。
  `arguments`是动态参数，只存在于函数中的伪数组
```javascript
function add() {
  let sum = 0;
  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i];
  }
  console.log(sum);
}
add(1, 2, 3);//此时无论传入多少参数，都能求和
```
6. **剩余参数：** 剩余参数允许将一个不定数量的参数表示为一个数组。
   ...是一个语法符号，置于最末函数形参前，用于获取多余的实参
   借助...获取的剩余实参是一个真数组(更提倡使用)
```javascript
function add(x,y,...args) {//...args表示剩余参数
console.log(args);
}
add(1, 2, 3);//3会被保存在args中，此时args为[3]
```
7. **展开运算符：** 展开运算符(...)允许将一个数组展开为多个参数。
`console.log(...[1,2,3]); //输出1 2 3`
用于求最大值： `Math.max(...[1,2,3]); //输出3`
合并数组： `[...[1,2],...[3,4]]; //输出[1,2,3,4]`
8. **箭头函数：** 
   `const add = function(a,b) { console.log( a + b ); }`
   `const add = (a,b) => { console.log( a + b ); }`
   若参数只有一个，则圆括号可以省略；若只有一行代码，还可以省略大括号： `const add = a =>  console.log( a + 1 ); `
   若有返回值，只有一行代码，return可以省略： `const add = a => a + 1;`
   箭头函数可以直接返回对象：jie： `const add = (a,b) => ({a:a,b:b});`
   箭头函数中没有arguments动态参数，但有剩余参数： `const add = (...args) => args;`
   **箭头函数的this指向**： 
   this在普通函数中指向调用它的对象
   箭头函数this指向上一层作用域的this
9. **数组解构：** 
    `const [a,b] = [1,2];` 将数组的单元值批量赋值给变量。
    还可以用于交换数组：`let a = 1; let b = 2;  [a,b] = [b,a];`单独的数组解构语句前若有代码，则必须要在语句前加分号。
    遇到变量多，参数少的情况时，多出来的变量值为undefined。可以给变量赋值来解决该问题：`const [a = 4,b = 6,c = 3] = [1,2];`若有参数传进来，则会覆盖掉原有变量值。
    遇到变量少，参数多的情况时，多出来的参数被忽略。可用剩余参数来解决该问题：
    `const [a,b,...rest] = [1,2,3,4,5];`
    数组按需导入赋值：`const [a, b, , c] = [1, 2, 3, 4];`此时a为1，b为2，c为4。
    二维数组：`const arr = [ [1 , 2],[3 , 4] ];` 若要取出1，则`arr[0][0]`
10. 对象解构：`const {a , b} = {a : 1 , b : 2};` 等价于`const a = 对象名.a; const b = 对象名.b;`
    对象属性的值将被赋值给与属性名相同的变量
    主义外面的变量名不能和对象解构的属性名相同, 若同名，可以给解构属性名改名：
    `const {a : a1 , b : b1} = {a : 1 , b : 2};`
    对象中找不到与变量名一致的属性时变量值为undefined
    解构数组对象：`const [{a , b}] = [{a : 1 , b : 2}];`
    多级对象解构：`const {a , {b , c}} = {a : 1 , {b : 2 , c : 3}};`
11. **forEach()** 
    `forEach()`方法用于调用数组的每个元素，并将元素传递给回调函数。
    遍历数组中的每个元素
    `数组.forEach(function(当前数组元素, 当前元素的索引号){ 函数体 })`
12. **filter()** 创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。
    `被遍历的数组.filter(function(当前数组元素, 当前元素的索引号){ return 筛选条件})`
13. **构造函数：**
    创建对象实例的函数，构造函数的函数名必须与类名相同。
    **new实例化的过程：**
    1.创建一个新对象
    2.构造函数的this指向新对象
    3.执行构造函数代码，修改this，添加新属性
    4.返回新对象
```javascript
function Person(name, age) { //函数名首字母大写
this.name = name;
this.age = age;
//构造函数中return无效
}
const person = new Person('张三', 18); //用new来执行
```
14.  **实例成员：** 
   通过构造函数创建的对象称作实例对象，实例对象中的属性和方法称为实例成员。
   为构造函数传入参数，创建结构相同但值不同的对象。
   构造函数创建的实例对象彼此互不影响。
   **静态成员：** 
   构造函数的属性和方法被称为静态成员。
   静态成员只能通过构造函数访问。
   静态方法的this指向构造函数。
```javascript
function Person() { //实例对象
  this.name = 'John';  // 实例属性
  this.age = '18';
  this.sayName = function() {  // 实例方法
    console.log('xxx');
    }
}
```
```javascript
function Person(name , age) { 
  this.name = name;
  this.age = age;
}
Person.eyes = 2; // 静态属性
Person.sayName = function() {  // 静态方法
  console.log(this.eyes); //this指向Person
  }
```
15. **内置构造函数：**
    基本数据类型有：字符串、数字、布尔、undefined、null。
    引用类型是：对象、数组、函数、正则、Date。
    但`const str = 'hello'; console.log(str.length);`会返回4。
    JS会把基本数据类型自动包装成引用数据类型(对象)
    字符串、数字、布尔有专门的构造函数：String、Number、Boolean，称之为包装类型。
16. **静态方法：**
    **关于Object的静态方法：** 
    `Object.keys(对象名)`: 返回一个数组，获得对象中所有的属性名。
    `Object.values(对象名)`: 获得对象中所有的属性值。
    `Object.assign(目标对象,源对象)`: 浅拷贝对象。 
    **关于Array的静态方法：**
    `arr.reduce(function(上一次值，当前值){}, 初始值)`
    如果没有起始值，则上一次值以数组的第一个元素的值。
    每一次循环，把返回值给作为下一次循环的上一次值。
    如果有起始值，则起始值做上一次值。 
    若是列表对象的属性值求和，则初始值要设置成0
    `arr.join(分隔符)` 将数组拼接成字符串，返回字符串
    `arr.find()` 找到第一个满足条件的元素，返回该元素
    `arr.every()` 循环数组，返回所有元素都满足条件时返回true，否则返回false
    `arr.from()` 将伪数组对象转为数组
    **字符串方法:**
    `str.length` 字符串长度
    `str.split(分隔符)` 将字符串转为数组
    `str.substring(截取的第一个字符的索引[,结束的索引])` 截取字符串
    `str.startsWith(字符串[,检测位置的索引])` 判断字符串是否以某个字符串开头
    `str.includes(字符串[,检测位置的索引])` 判断字符串是否包含在另一个字符串中
### 十五、编程思想
1. **面向过程：** 分析步骤，用函数将步骤一步步地实现，使用时依次调用。
2. **面向对象(oop)：** 将事务分解成一个个对象，然后由对象之间分工合作。
   JS的面向对象可以通过构造函数实现封装，但会出现内存浪费的问题。
### 十六、原型
1. **原型：** 
   JS规定，每个构造函数都有一个prototype属性，指向另一个对象，称之为原型对象。
   这个对象可以挂载函数，对象实例化不会多次创建原型上函数，节约内存。
   把那些不变的方法，直接定义在原型对象上，这样，实例对象就会继承这些方法。
   构造函数和原型对象的this都是指向实例对象。
   **创建对象时，公共的属性写进构造函数，公共的方法写进原型对象。**
2. **constructor属性**
   原型对象中都有constructor属性，`__proto__`中也有。
   该属性指向原型对象的构造函数，指向它的父亲。
   当有多个对象的方法，可以给原型对象采取对象形式的赋值。
   但是这样就会覆盖构造函数原型对象原来的内容，此时constructor属性会丢失。
   可以在修改后的原型对象里，添加constructor属性指向原来的构造函数。
```javascript
function Person(name) {
  this.name = name;
};
Person.prototype = {
  constructor: Person, // constructor属性指向Person
  sing: function () {
    console.log("sing");
  },
  dance: function () {
    console.log("dance");
  },
}
const p = new Person('王五');
console.log(this === p); // true,构造函数和原型对象的this都是指向实例对象。
```
3. **原型对象：**
   对象都会有一个属性`__proto__`，这个属性指向函数的prototype原型对象。
   部分浏览器会将`__proto__`属性改名为`[[prototype]]`。
   `__proto__`属性中也有一个属性`constructor`，这个属性指向构造函数。
4. **原型继承：**
```javascript
function Person() { //使用构造函数声明对象
  this.eyes = 2;
  this.ears = 2;
}
function Woman() {}
Woman.prototype = new Person(); //通过原型的方式继承Person
Woman.prototype.constructor = Woman; //重写constructor属性
```
5. **原型链继承：**
   基于原型对象的继承使得不同构造函数的原型对象关联在一起，并且是一种链状结构，把这种链状结构关系称之为原型链。
   **查找规则：**
  1.先查找自身对象有没有该属性。
  2.如果没有，则查找原型对象有没有该属性。(即__proto__属性指向的prototype对象)
  3.如果没有，则继续查找原型对象的原型。直至查到Object为止。若还是没有，则返回null。
  3.可以使用instanceof运算符来检测构造函数的prototype属性是否出现在某个实例对象的原型链上。
  `console.log(Array instanceof Object);` 返回true
  
   
