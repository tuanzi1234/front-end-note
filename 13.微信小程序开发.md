### 一、小程序目录结构
1. **`pages:`** 存放小程序页面文件
   其中:
   `.js`: 页面脚本文件
   `.json`: 页面配置文件
   `.wxml`: 存放页面的模板文件
   `.wxss`: 存放页面的样式文件
2. **`utils:`** 存放小程序工具类文件
3. **`app.js:`** 小程序入口文件(通过调用App()函数启动整个小程序)
4. **`app.json:`** 小程序全局配置文件
5. **`app.wxss:`** 小程序全局样式文件
6. **`project.config.json:`** 小程序项目配置文件
7. **`sitemap.json:`** 配置小程序及其页面是否允许被微信索引
8. **小程序中的.json文件:**
   1.**根目录的`app.json`**
   `app.json`目录结构:
   ```json
   { "pages": [ "pages/index/index" ],
     "window": {
        "backgroundTextStyle": "light",
        "navigationBarBackgroundColor": "#fff",
        "navigationBarTitleText": "WeChat",
        "navigationBarTextStyle": "black"
        },
      "style": "v2",
      "sitemapLocation": "sitemap.json"
    }
   ```
   **`pages:`** 记录小程序的页面路径(在pages中创建路径会创建对应的页面文件，排在前的页面会优先显示)
   **`window:`** 
   配置小程序的窗口样式(该项配置的样式会被页面的json文件覆盖)
   可用于配置 **`navigationBar`(顶部导航栏):**
   (1)`navigationBarBackgroundColor`(导航栏背景颜色，只支持十六进制色值)
   (2)`navigationBarTextStyle`(导航栏文字颜色, 只支持黑色和白色)
   (3)`navigationBarTitleText`(导航栏标题内容)
   **`background`(背景):**
   (1)`backgroundColor`(下拉刷新时页面背景颜色, 只支持十六进制色值)
   (2)`backgroundTextStyle`(设置页面下拉刷新时loading颜色, 只支持dark和light)
   **页面主体区域:**
   (1)`enablePullDownRefresh`(是否允许下拉刷新，值为布尔值，默认为false，若要设置下拉功能，建议在页面单独设置，而不是在`app.json`中设置)
   若要监听下拉动作，可在js文件中使用`onPullDownRefresh: function() { 相关逻辑 }`方法；
   下拉刷新不会自动重置，若要重置，可在上述方法中使用`wx.stopPullDownRefresh()`方法。
   (2)`onReachBottomDistance`(触发上拉触底的距离, 单位为px，默认50px，无特殊需求不建议修改) 
   **`tabBar:`** 配置小程序的导航栏样式, 类似于子路由，有顶部和底部两种，渲染顶部`tabBar`时不会渲染icon，只显示文本。渲染`tabBar`时，最多可以设置五个页签，最少设置两个。
   渲染`tabBar`的页签需要放在`pages`的第一行
   `tabBar`的配置项：
   (1)`backgroundTextStyle`(`tabBar`背景颜色)
   (2)`borderStyle`(`tabBar`边框颜色)
   (3)`selectedColor`(`tabBar`选中的文字颜色)
   (4)`color`(`tabBar`未选中文字颜色)
   在`tabBar`中配置list，用于页面跳转:
   (5)`selectedIconPath`(`tabBar`选中的图标路径)
   (6)`iconPath`(`tabBar`未选中时的图标路径)
   (7)`pagePath`(跳转的页面路径(必填))
   (8)`text`(tab上按钮显示的文字(必填))
   **`style:`** 配置小程序的样式版本
   2.**`pages`目录下的`page.json`**
   遵从就近原则，会覆盖`app.json`中的配置
   具体的配置项和app.json一致
   3.**项目中的`project.config.json`**
   其中，`setting`保存了编译相关配置
   `projectname`: 项目名称
   `appid`: 小程序ID
   4.**`sitemap.json`** 
   控制是否允许搜索引擎搜索，由action字段控制，将值改为disallow即可禁止搜索
9. **小程序中的js文件**
   `app.js`: 整个小程序的入口，用`App()`函数来启动
   `page.js`: 页面入口，用`Page()`函数来启动
   `utils.js`: 封装公告的属性和功能
### 二、小程序的组件
1. **视图容器类:**
   1.**`view`**: 类似于`div`标签
   2.**`scroll-view`**: 滚动视图区域
     在`scroll-view`标签中，设置属性`scroll-x`或`scroll-y`，再给容器设置固定高度即可实现横向或纵向的滚动。
   3.**`swiper`**: 轮播图组件
     在`swiper`标签中，设置属性`indicator-dots`，在`swipe-item`标签中，设置需要展现的内容就可实现轮播图效果
     **轮播图组件的属性**:
     1.`indicator-dots`: 是否显示面板指示点
     2.`indicator-color`: 指示点颜色
     3.`indicator-active-color`: 当前选中的指示点颜色
     4.`autoplay`: 是否自动切换
     5.`interval`: 自动切换时间间隔
     6.`circular`: 是否衔接滑动
   4.**text**: 文本组件，类似于HTML中的span标签
     **rich-text**: 富文本组件，支持将HTML标签解析成对应的小程序组件
### 三、小程序的API
1. **事件监听类:**
   以`on`开头的事件监听函数
   例如: `wx.onWindowResize(callback)` 监听窗口尺寸变化
2. **同步API:**
   以`Sync`结尾的API，同步API执行的结果可以通过函数返回值直接获取，如果出现错误会抛出异常
   例如: `wx.swtStorageSync('key', 'value')` 向本地存储中写入内容
3. **异步API:**
   `wx.request({})`发送网络请求就是一个异步API，通过`success`回调函数获取结果
### 三、数据绑定
1. **绑定数据:**
   在对应的页面js文件中，在`page(data:{})`中定义需要绑定的数据，在页面中使用`{{ 数据名 }}`来绑定数据
2. **绑定属性:**
   若要绑定图片，则在`page(data:{})`中定义图片的url，在页面中使用`<image src="{{ 数据名 }}" />`来绑定图片
   **除开绑定属性可以在标签中直接使用`{{}}`以外，其他语法和Vue基本一致**
### 四、事件绑定
1. **常见事件:**
   `top`: 类似于click事件，在标签内使用`bindtap="事件名"`来绑定
   `input`: 输入框内容改变时触发，在标签内使用`bindinput="事件名"`来绑定
   `change`: 状态改变时触发，在标签内使用`bindchange="事件名"`来绑定
2. **事件触发后，回调的event对象:**
   `type`: 事件类型
   `timeStamp`: 事件触发时的时间戳
   `target`: 触发事件的组件的属性值，指向触发事件的源头组件，
   `currentTarget`: 当前组件的属性值，仅指向使用该属性的组件。
   `detail`: 额外的信息
   `touchs`: 触摸点信息(触发事件时手机屏幕上有几个手指)
   `changedTouches`: 当前事件变化的触摸点信息的数组
3. **小程序的事件传参:**
   小程序不能像Vue那样在事件名后加括号来传参。
   若要传参，则需要在标签中使用`data-参数名`前缀来绑定参数，在回调函数中通过`event.target.dataset.参数名`获取参数
4. **bindinput事件:**
   在输入框组件中使用`value="{{ 数据名 }}"`来绑定数据，在输入框组件中使用`bindinput="事件名"`来绑定事件
   `bindinput`事件会触发多次，每次输入一个字符都会触发一次，若要获取输入的字符串，则需要使用`event.detail.value`来获取
### 五、条件渲染:
   在标签内使用`wx:if="{{条件}}"`来判断是否显示标签
   若希望对多个组件进行批量条件渲染，可以对组件使用`block`标签包裹，在`block`标签内使用`wx:for="{{条件}}"`(控制复杂组件时使用，搭配`wx:elif"`和`wx:else`使用)
   还可以使用`hidden="{{条件}}"`属性来隐藏标签(频繁切换时使用)
   **区别:**
   `wx:if`: 是使用动态创建和移除标签的方式控制元素的显示和隐藏
   `hidden`: 是使用`display: none/block`隐藏元素的方式控制元素的显示和隐藏
### 六、列表渲染:
   通过`wx:for="{{array}}"`来渲染列表，索引是`index`，循环项是`item`
   通过`wx:for-index="index"`和`wx:for-item="item"`来指定索引的变量名和循环项的变量名
   通过`:key="id"`来指定列表项的唯一key值，key的作用是优化列表的渲染性能
### 七、wxss
   **就近原则:** 
   当局部样式和全局样式冲突时，局部样式会覆盖全局样式；并且只有当局部样式的权重大于或等于全局样式时，才会触发就近原则。
### 八、网络数据请求
1. **限制:**
   微信小程序开发中，对于请求接口做出了限制:
   (1)域名只能请求`https`接口
   (2)需要将域名添加到新人列表中
   (3)域名不能使用ip地址或localhost
   (4)域名必须是经过ICP备案的
   (5)服务器域名一个月只能申请5次
2. **发起GET请求**
   ```js
   wx.request({
      url: 'https://具体域名',
      method: 'GET',
      data: {
         name: '张三'
         age: 18
      },
      success: (res) => {
         console.log(res.data)
      }
   })
   ```
3. **发起POST请求**
   ```js
   wx.request({
      url: 'https://具体域名',
      method: 'POST',
      data: {
         name: '张三'
         age: 18
      },
      success: (res) => {
         console.log(res.data)
      }
   })
   ```
4. **立即发送请求**
   在`onLoad`生命周期函数中发起请求
   `options`为页面跳转所带来的参数,在`data`中定义`query:{}`对象可以获取参数
   ```js
   onLoad: function(options) {
      this.方法名()
      this.setData({
         query: options // 将参数保存在data中
      })
   }
   ```
5. **在开发阶段，可以通过勾选本地设置中"不校验合法域名..."来忽略域名校验**
6. **微信小程序不存在跨域问题**
   **小程序中的请求应该叫做"发起网络数据请求"，与ajax无关。**
### 九、页面导航
1. **声明式导航**
   页面上声明一个`<navigator>`标签，并设置`url`属性，点击标签，就会跳转到指定页面
   **导航到tabBar页面：**
   指定`url`, 以`/`开头
   指定`open-type`属性为`switchTab`
   **导航到非tabBar页面：**
   指定`url`, 以`/`开头，路径后可携带参数
   参数与路径之间使用`?`连接，参数键值对之间使用`=`连接
   不同参数之间使用`&`连接
   指定`open-type`属性为`navigate`
   **返回上一页：**
   指定`open-type`属性为`navigateBack`
   指定`delta`属性为返回的页面数, 用数字表示后退的层级, 默认为1(为1时可省略)
2. **编程式导航** 
   调用导航API，实现页面跳转  
   **导航到tabBar页面:**
   调用`wx.switchTab(Object object)`方法，可跳转到tabBar页面。其中Object对象参数为：
   `url`: 必填，跳转的tabBar页面路径, 路径后不带参数
   `success`: 可选，接口调用成功的回调函数
   `fail`: 可选，接口调用失败的回调函数
   `complete`: 可选，接口调用结束的回调函数（调用成功、失败都会执行）
   **导航到非tabBar页面:**
   与`wx.switchTab()`方法类似，调用`wx.navigateTo(Object object)`方法，可跳转到非tabBar页面。区别就是`wx.navigateTo(Object object)`方法中的`url`路径后可带参数。参数写法与声明式导航一致
   **返回上一页面:**
   调用`wx.navigateBack(Object object)`方法，可返回上一页面。通过设定`delta`参数的number值，可返回指定页面(默认值为1，当值为1时可省略)。其余参数与`wx.switchTab()`方法相同。
### 十、生命周期
1. **应用生命周期:**
   小程序从启动、运行、销毁的过程
   ```js
   APP({
      // 小程序初始化完成时，执行该函数，全局只执行一次
      onLaunch: function(options) {}
      // 小程序启动时，或者从后台进入前台时触发
      onShow: function(options) {}
      // 小程序从前台进入后台时触发
      onHide: function() {}
   })
   ```
2. **页面生命周期:**
   小程序中每个页面的加载、渲染、销毁的过程
   ```js
   Page({
      // 监听页面加载，一个页面只执行一次
      onLoad: function(options) {}
      // 监听页面显示
      onShow: function() {}
      // 监听页面初次渲染完成，一个页面只执行一次
      onReady: function() {}
      // 监听页面隐藏
      onHide: function() {}
      // 监听页面卸载，一个页面只执行一次
      onUnload: function() {}
   })
   ```
**其中，页面生命周期的范围比应用程序生命周期小**
### 十一、wxs
类似于javascript, 但有区别:
1. **数据类型:**
   number, string, boolean, array, object, function, date, regexp
2. **wxs不支持ES6语法**
   不支持let, const, 解构赋值, 展开运算符, 箭头函数, 对象属性简写, etc
   支持var定义变量, 普通function函数等类似于ES5的语法
3. **遵循CommonJS规范**
   module对象
   require()方法
   exports对象
4. **基本语法**
   **内嵌wxs语法:** 写在`<wxs>`标签内
   ```html
   <!-- wxs方法调用 -->
   <view>{{m1.toUpper(xxx)}}</view>
   <!-- wxs内嵌写法 -->
   <wxs module="wxs">
   module.exports.toUpper = function(str) {
      return str.toUpperCase();
   }
   </wxs>
   ```
   **外联wxs语法:** 先创建一个独立的.wxs文件, 然后在`<wxs src="文件路径">`标签内引入
5. **wxs特点**
   1.wxs不能作为组件的事件回调, 只能和mustache配合作为过滤器使用。例如`<button bindtap="wxs.方法名">`是错误写法
   2.wxs和js是完全隔离的，wxs不能调用js的方法，wxs不能调用小程序提供的API
   3.IOS设备上，wxs性能优于js，安卓二者性能基本相同
### 十二、自定义组件
1. **创建组件**
   在项目目录下创建components文件夹，在components文件夹下右键点击新建Component
   在需要使用组件的页面json中配置: 
   `"usingComponents": { "my-component": "components/页面组件名称" }`
   若希望全局引用组件，可以在app.json中配置:
   `"usingComponents": { "my-component": "components/页面组件名称" }`
   **组件与页面的不同:**
   组件的.json文件中需要声明: `"component": true"`
   组件的.js文件中调用的是`Component()`方法
   组件的事件处理函数需要定义到`methods`中
2. **组件样式隔离**
   组件之间不会相互影响
   组件的样式不会对页面造成影响
   只有class选择器才会触发样式隔离，id选择器、属性选择器、标签选择器不会。
   **修改组件的样式隔离选项**
   在组件的js文件中定义`options`对象，并设置`styleIsolation`属性为`isolated`
   ```js
   Component({
      options: {
         styleIsolation: 'isolated'
      }
   })
   ```
   或者在组件的json文件中定义`styleIsolation`属性为`isolated`
   其中，`styleIsolation`属性有三个值: 
   `isolated`: 启用样式隔离，在组件内外使用class选择器时，组件的样式不会对页面造成影响。
   `shared`: 表示页面wxss样式会影响到自定义组件，自定义组件wxss中指定的样式也会影响页面和设置了`shared`和`apply-shared`的组件。
   `apply-shared`: 表示页面wxss样式会影响到自定义组件，自定义组件wxss中指定的样式不会影响页面。
3. **自定义组件的数据、方法和属性**
   在小程序组件中，数据需要定义在`Component()`函数的`data`中。
   事件处理函数和自定义方法需要定义在`methods`中。自定义方法建议在函数名左边添加`_`，如`_myMethod()`，同事件处理函数做区分。
   **properties属性**
   用于定义组件的属性，用来接收外界传递到组件的数据。
   传递number时，可以在标签中添加: `<my-component number="1"></my-component>`。
   ```js
   Component({
      properties: {
         number: {
            type: Number, // 属性类型
            value: 0 // 属性初始值
         }
      }
   })
   ```
   **data和properties的区别**
   data和properties在小程序中都是可读可写的，不过data倾向于存储私有数据，properties则更倾向于存储外界传递到组件中的数据。
   data和properties在微信小程序中本质上并没有区别，因此properties的值也可用于页面渲染，或者使用`setData()`方法为其重新赋值。
   
