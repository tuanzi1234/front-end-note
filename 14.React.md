### 一、初始化react项目
1. **创建项目**
   执行命令: `npx create-react-app my-app`
   其中`npx`是Node.js的命令; `create-react-app`是react核心包; `my-app`是项目的名称
### 二、JSX语法
   JSX是JS语法的扩展，浏览器本身不识别，需要通过解析工具才能在浏览器中运行
1. **JS表达式**
   在JSX中，你可以使用{}来包含JS表达式
   ```jsx
   const getName = () => 'zhangsan';
   const number = 1;
   function APP() {
      return (
      <div className="App">
         Hello World！
         {/* 使用引号传递字符串 */}
         {'Hello World'}
         {/* 识别变量 */}
         {number}
         {/*函数调用*/}
         {getName()}
         {/*方法调用*/}
         {new Date().toLocaleTimeString()}
         {/*JS对象*/}
         <div style={{color: 'red'}}>hello world</div>
      </div>
      )
   }
   ```
2. **列表渲染**
   ```jsx
   const list = [
      {id: 1, name: '张三'},
      {id: 2, name: '李四'},
      {id: 3, name: '王五'}
   ];
   function APP() {
      return (
         <div className="App">
            <ul>
            {/* 列表渲染 */}
            {/* 一定要加上独立的key属性，react内部使用，用于提升性能 */}
            {list.map(item => <li key={item.id}>{item.name}</li>)}
            </ul>
         </div>
      )
   }
   ```
3. **条件渲染**
   ```jsx
   // 通过布尔值来判断内容是否显示
   const isLogin = true;
   function APP() {
      return (
         <div className="App">
         {/* 逻辑运算符 */}
         {isLogin && <div>已登录</div>}
         {/* 三元运算符 */}
         {isLogin ? <div>已登录</div> : <div>未登录</div>}
         </div>
      )
   }
   ```
   **复杂条件渲染**
   ```jsx
   const type = 2;
   function getType() { 
      if (type === 1) {
         return <div>类型1</div>
      } else {
         return <div>其他类型</div>
      }
   }
   function APP() {
      return (
         <div className="App">
         {getType()}
         </div>
      )
   }
   ```
6. **事件绑定**
   ```jsx
   const handleClick = (name, e) => {
      console.log(name, e)
   }
   function APP() {
      return (
         <div className="App">
         {/* 绑定事件, 根据需要传递参数 */}
         <button onClick={(e) => handleClick('张三', e)}>点击</button>
         </div>
      )
   }
   ```
### 三、组件的封装与使用
   ```jsx
   // 定义组件
   function Button() {
      return <button>点击</button>
   }
   function App() {
      return (
         <div className="App">
         {/* 使用组件 */}
         <Button />
         </div>
      )
   }
   ```
### 四、状态管理
1. **useState是React Hooks，允许我们向组件添加一个状态变量，影响组件的渲染结果**
   ```jsx
   // 其中，useState()是一个函数，返回一个数组
   // 数组中第一个参数是状态变量，第二个参数是set函数，用来修改状态变量
   // useState()的参数是初始值
   const [count, setCount] = useState(0);
   ```
   **状态修改的规则**
   1.状态变量不能直接修改，必须通过set函数来修改
   2.对于对象类型的状态变量，应当始终传给set方法一个新的对象修改
2. **classnames优化类名**
    1.安装classnames包：`npm install classnames`
    2.引入classnames包：`import classnames from 'classnames'`
    3.使用classnames包： `className={classnames('active', {disabled: isDisabled})}`
3.  **表单受控绑定**
    1.准备react状态值: `const [value, setValue] = useState('');`
    2.通过value属性绑定状态，通过onChange属性绑定状态同步函数
    `<input type="text" value={value} onChange={(e) => setValue(e.target.value)} />`
4.  **react获取DOM元素**
    使用useRef创建ref对象, 并与JSX绑定
    `const inputRef = useRef(null);`
    `<input type="text" ref={inputRef} />`
5.  **id和日期处理**
    **处理id**: 
    使用`npm install uuid`安装uuid包，
    引入uuid包: `import { v4 as uuidv4 } from 'uuid';`
    在需要的地方直接使用方法: `uuidv4()`
    **处理日期**:
    使用`npm install dayjs`安装dayjs包
    引入dayjs包: `import dayjs from 'dayjs';`
    在需要地方使用方法: `dayjs().format('YYYY-MM-DD HH:mm:ss')`
### 五、组件通信
1. **父组件向子组件传递数据**
   (1)父组件传递数据： `<ChildComponent data={data} />`子组件上绑定属性
   (2)子组件接收数据： 使用props接收数据:
   ```jsx
   function ChildComponent(props) {
   return (
   <div>{props.data}</div>
   )}
   ```
   **关于props**: 
   (1)props可以传递任意数据，数字，字符串，对象，数组，函数，JSX等等
   (2)props是只读的，不能修改props中的数据，若要修改数据只能由父组件进行
   (3)当内容嵌套在子组件标签中时，父组件会自动在children的prop中接收内容
2. **子组件向父组件传递数据**
   在子组件中调用父组件的方法，传递参数
   ```jsx
   // 子组件
   function ChildComponent({onGetData}) {
      const sonData = '子组件数据'
      return (
         <button onClick={() => onGetData(sonData)}>点击获取数据</button>
      )
   }
   // 父组件
   function ParentComponent() {
       // 存储数据
      const [data, setData] = useState('')
      const getData = (data) => {
         console.log(data)
         setData(data)
      }
      return (
         <div>{data}</div>
         <ChildComponent onGetData={getData} />
      )
   }
   ```
3. **兄弟组件通信**
   借助状态提升，通过父组件进行兄弟组件间的通信
   ```jsx
   // 1.通过子组件A向父组件传递数据
   function ChildA({onGetData}) {
      const data = '子组件A数据'
      return (
         <button onClick={() => onGetData(data)}>点击获取数据</button>
      )
   }
   // 2.通过父组件向子组件B传递数据
   function ParentComponent() {
      const [data, setData] = useState('')
      const getData = (data) => {
         console.log(data)
         setData(data)
      }
      return (
         <ChildA onGetData={getData} />
         <ChildB data={data} />
      )
   }
   // 3.子组件B接收数据
   function ChildB(props) {
      return (
         <div>{props.data}</div>
      )
   }
   ```
4. **利用context跨层通信**
   (1)使用createContext创建context对象
   (2)在顶层组件(App)中通过Provider组件提供数据
   (3)在底层组件(B)中通过useContext接收数据
   ```jsx
   import { createContext, useContext } from 'react';
   // 创建context对象
   const MyContext = createContext();
   function App() {
      const data = 'hello world';
      return (
         <div>
         {/* 提供数据 */}
         <MyContext.Provider value={data}>
         <A />
         </MyContext.Provider>
         </div>
      )
   }
   function A() {
      return (
         <div>A</div>
         <B />
      )
   }
   function B() {
      // 跨过A组件接收数据
      const data = useContext(MyContext);
      return (
         <div>{data}</div>
      )
   }
   ```