### 一、初始化react项目
1. **创建项目**
   执行命令: `npx create-react-app my-app`
   其中`npx`是Node.js的命令; `create-react-app`是react核心包; `my-app`是项目的名称
### 二、JSX语法
   JSX是JS语法的扩展，浏览器本身不识别，需要通过解析工具才能在浏览器中运行
1. **JS表达式**
   在JSX中，你可以使用{}来包含JS表达式
   ```jsx
   const getName = () => 'zhangsan';
   const number = 1;
   function APP() {
      return (
      <div className="App">
         Hello World！
         {/* 使用引号传递字符串 */}
         {'Hello World'}
         {/* 识别变量 */}
         {number}
         {/*函数调用*/}
         {getName()}
         {/*方法调用*/}
         {new Date().toLocaleTimeString()}
         {/*JS对象*/}
         <div style={{color: 'red'}}>hello world</div>
      </div>
      )
   }
   ```
2. **列表渲染**
   ```jsx
   const list = [
      {id: 1, name: '张三'},
      {id: 2, name: '李四'},
      {id: 3, name: '王五'}
   ];
   function APP() {
      return (
         <div className="App">
            <ul>
            {/* 列表渲染 */}
            {/* 一定要加上独立的key属性，react内部使用，用于提升性能 */}
            {list.map(item => <li key={item.id}>{item.name}</li>)}
            </ul>
         </div>
      )
   }
   ```
3. **条件渲染**
   ```jsx
   // 通过布尔值来判断内容是否显示
   const isLogin = true;
   function APP() {
      return (
         <div className="App">
         {/* 逻辑运算符 */}
         {isLogin && <div>已登录</div>}
         {/* 三元运算符 */}
         {isLogin ? <div>已登录</div> : <div>未登录</div>}
         </div>
      )
   }
   ```
   **复杂条件渲染**
   ```jsx
   const type = 2;
   function getType() { 
      if (type === 1) {
         return <div>类型1</div>
      } else {
         return <div>其他类型</div>
      }
   }
   function APP() {
      return (
         <div className="App">
         {getType()}
         </div>
      )
   }
   ```
6. **事件绑定**
   ```jsx
   const handleClick = (name, e) => {
      console.log(name, e)
   }
   function APP() {
      return (
         <div className="App">
         {/* 绑定事件, 根据需要传递参数 */}
         <button onClick={(e) => handleClick('张三', e)}>点击</button>
         </div>
      )
   }
   ```
### 三、组件的封装与使用
   ```jsx
   // 定义组件
   function Button() {
      return <button>点击</button>
   }
   function App() {
      return (
         <div className="App">
         {/* 使用组件 */}
         <Button />
         </div>
      )
   }
   ```
### 四、状态管理
1. **useState是React Hooks，允许我们向组件添加一个状态变量，影响组件的渲染结果**
   ```jsx
   // 其中，useState()是一个函数，返回一个数组
   // 数组中第一个参数是状态变量，第二个参数是set函数，用来修改状态变量
   // useState()的参数是初始值
   const [count, setCount] = useState(0);
   ```
   **状态修改的规则**
   1.状态变量不能直接修改，必须通过set函数来修改
   2.对于对象类型的状态变量，应当始终传给set方法一个新的对象修改
2. **classnames优化类名**
    1.安装classnames包：`npm install classnames`
    2.引入classnames包：`import classnames from 'classnames'`
    3.使用classnames包： `className={classnames('active', {disabled: isDisabled})}`
3.  **表单受控绑定**
    1.准备react状态值: `const [value, setValue] = useState('');`
    2.通过value属性绑定状态，通过onChange属性绑定状态同步函数
    `<input type="text" value={value} onChange={(e) => setValue(e.target.value)} />`
4.  **react获取DOM元素**
    使用useRef创建ref对象, 并与JSX绑定
    `const inputRef = useRef(null);`
    `<input type="text" ref={inputRef} />`
5.  **id和日期处理**
    **处理id**: 
    使用`npm install uuid`安装uuid包，
    引入uuid包: `import { v4 as uuidv4 } from 'uuid';`
    在需要的地方直接使用方法: `uuidv4()`
    **处理日期**:
    使用`npm install dayjs`安装dayjs包
    引入dayjs包: `import dayjs from 'dayjs';`
    在需要地方使用方法: `dayjs().format('YYYY-MM-DD HH:mm:ss')`
### 五、组件通信
1. **父组件向子组件传递数据**
   (1)父组件传递数据： `<ChildComponent data={data} />`子组件上绑定属性
   (2)子组件接收数据： 使用props接收数据: **当父组件重新渲染时，子组件也会重新渲染**
   ```jsx
   function ChildComponent(props) {
   return (
   <div>{props.data}</div>
   )}
   ```
   **关于props**: 
   (1)props可以传递任意数据，数字，字符串，对象，数组，函数，JSX等等
   (2)props是只读的，不能修改props中的数据，若要修改数据只能由父组件进行
   (3)当内容嵌套在子组件标签中时，父组件会自动在children的prop中接收内容
2. **子组件向父组件传递数据**
   在子组件中调用父组件的方法，传递参数
   ```jsx
   // 子组件
   function ChildComponent({onGetData}) {
      const sonData = '子组件数据'
      return (
         <button onClick={() => onGetData(sonData)}>点击获取数据</button>
      )
   }
   // 父组件
   function ParentComponent() {
       // 存储数据
      const [data, setData] = useState('')
      const getData = (data) => {
         console.log(data)
         setData(data)
      }
      return (
         <div>{data}</div>
         <ChildComponent onGetData={getData} />
      )
   }
   ```
3. **兄弟组件通信**
   借助状态提升，通过父组件进行兄弟组件间的通信
   ```jsx
   // 1.通过子组件A向父组件传递数据
   function ChildA({onGetData}) {
      const data = '子组件A数据'
      return (
         <button onClick={() => onGetData(data)}>点击获取数据</button>
      )
   }
   // 2.通过父组件向子组件B传递数据
   function ParentComponent() {
      const [data, setData] = useState('')
      const getData = (data) => {
         console.log(data)
         setData(data)
      }
      return (
         <ChildA onGetData={getData} />
         <ChildB data={data} />
      )
   }
   // 3.子组件B接收数据
   function ChildB(props) {
      return (
         <div>{props.data}</div>
      )
   }
   ```
4. **利用context跨层通信**
   (1)使用createContext创建context对象
   (2)在顶层组件(App)中通过Provider组件提供数据
   (3)在底层组件(B)中通过useContext接收数据
   ```jsx
   import { createContext, useContext } from 'react';
   // 创建context对象
   const MyContext = createContext();
   function App() {
      const data = 'hello world';
      return (
         <div>
         {/* 提供数据 */}
         <MyContext.Provider value={data}>
         <A />
         </MyContext.Provider>
         </div>
      )
   }
   function A() {
      return (
         <div>A</div>
         <B />
      )
   }
   function B() {
      // 跨过A组件接收数据
      const data = useContext(MyContext);
      return (
         <div>{data}</div>
      )
   }
   ```
### 六、useEffect
1. **useEffect用于在React组件中创建不是由事件引起，而是由渲染本身引起的操作。**
   比如Ajax请求，更改DOM等等。
   例如: 组件渲染完毕后立即获取数据:
   ```jsx
   import { useEffect, useState } from 'react';

   function App() {
      const [data, setData] = useState([]);
      useEffect(() => {
         async function fetchData() {
            const res = await fetch('https://api.example.com/data');
            const data = await res.json();
            setData(data);
         }
         fetchData();
      }, [])
      return (
         <div>{data}</div>
      )
   }
   ```
2. **useEffect的参数**: 
   1.第一个参数是一个函数，这个函数会在组件渲染完毕后执行
   2.第二个参数是一个数组，是传入的依赖项，根据参数不同，有不同表现：
   (1)没有依赖项时，副作用函数会在组件渲染完毕后执行一次，并且每次组件更新时都会执行一次
   (2)传入一个空数组时，副作用函数只会在组件渲染完毕后执行一次
   (3)特定依赖项，副作用函数会在组件初始渲染时执行一次，特定依赖项变化时再次执行
3. **清除副作用**: 
   例如在useEffect中启动了一个定时器，在组件销毁时需要清除定时器，这就是清理副作用。
   该函数会在组件销毁时自动执行。
   ```jsx
   import { useEffect, useState } from 'react';
   function Son() {
      useEffect(() => {
         const timer = setInterval(() => {
            console.log('定时器执行中...')
         }, 1000)
      })
      return () => {
         clearInterval(timer)
      }
      return <div>子组件</div>
   }
   function App() {
      const [show, setShow] = useState(true);
      return (
         <div>
         {show && <Son />}
         <button onClick={() => setShow(false)}>删除子组件</button>
      )
   }
   ```
### 七、自定义hooks
1. **自定义hooks**: 以use开头的函数，可以封装一些通用逻辑，方便复用。
   **思路**: 
   (1)封装一个函数，函数名以use开头
   (2)函数内部封装逻辑(可复用的逻辑均可封装)
   (3)返回一个对象，对象中包含需要使用的变量和函数
   (4)在组件中用到这个逻辑就执行该函数，解构出状态和回调进行使用
   ```jsx
   import { useState } from 'react';
   // 自定义hooks，使show, setShow能够被其他组件使用, 控制组件的显示和隐藏
   function useToggle() {
      const [show, setShow] = useState(true);
      const toggle = () => setShow(!show);
      return {show, toggle};
   }
   function App() {
      const {show, toggle} = useToggle();
      return (
         <div>
         {show && <div>内容</div>}
         <button onClick={toggle}>{show ? '显示' : '隐藏'}</button>
         </div>
      )
   }
   ```
2. **ReactHook的使用规则**:
   (1)只能在组件中或其他自定义Hook中调用
   (2)只能在组件的顶层调用，不能嵌套在if、for、其他函数中
### 八、Redux
1. **Redux**: Redux是一个状态管理库，用于管理React应用中的状态，类似于Vuex和Pinia。
2. **使用Redux**: 
   (1)定义一个 **`reducer`函数(根据当前想做的修改返回一个全新的状态)**
   (2)使用`createStore`方法传入`reducer`函数，创建一个 **`store`对象(存放着管理数据的状态)**
   (3)使用`store.subscribe`方法订阅`store`对象，监听状态的变化，数据变化即可得到通知
   (4)使用`store.dispatch`方法提交一个 **`action`对象(描述如何改数据)**，触发数据变化(告诉`reducer`应当如何改数据)
   (5)使用`store.getState`方法获取当前最新状态更新到视图中
3. **Redux和React的环境准备**:
   安装工具: `npm i @reduxjs/toolkit react-redux` 
   **使用:**
   例子：利用ReduxToolkit实现数字增减
   ```jsx
   // 创建counterStore.js
   import { createSlice } from '@reduxjs/toolkit';

   const counterStore = createSlice({
      name: 'counter',
      // 初始状态
      initialState: {
         count: 0,
      },
      // 修改数据的同步方法
      reducers: {
         add: (state) => {
            state.count++
         },
         decrement: (state) => {
            state.count--
         },
         // 传参
         addByNum: (state, action) => {
            state.count += action.payload
         }
      }
   })
   // 解构出action对象的函数
   const { add, decrement } = counterStore.actions;
   // 获取reducer对象
   const counterReducer = counterStore.reducer;
   // 导出action对象的函数和reducer函数
   export { add, decrement };
   export default counterReducer;
   ```
   ```jsx
   // 创建store.js
   import { configureStore } from '@reduxjs/toolkit';
   import counterReducer from './counterStore';
   // 引入channelStore.js异步功能
   import channelReducer from './channelStore';

   // 创建根store组合子模块
   const store = configureStore({
      reducer: {
         counter: counterReducer,
         channel: channelReducer
      }
   })
   export default store;
   ```
   ```jsx
   // 在react中注入store
   import { Provider } from 'react-redux';
   import store from './store';

   const root = ReactDOM.createRoot(document.getElementById('root'));
   root.render(
      <Provider store={store}>
      <App />
      </Provider>
   )
   ```
   ```jsx
   // React组件中使用store的数据，使用useSelector
   // React组件修改store的数据，使用useDispatch
   import { useSelector, useDispatch } from 'react-redux';
   // 引入action对象的方法
   import { add, decrement, addByNum } from './counterStore';
   //引入异步方法函数
   import { getChannelList } from './channelStore';
   function App() {
      const {count} = useSelector(state => state.counter);// 与reducer中的属性名对应
      const {channelList} = useSelector(state => state.channel);// 将channelList数据解构到组件
      const dispatch = useDispatch(); // 获取dispatch方法
      // 使用useEffect触发移除请求执行
      useEffect(() => {
         dispatch(getChannelList());
      }, [dispatch])
      return (
         <div>
         <h1>{count}</h1>
         {/* 调用dispatch方法，触发action对象，修改数据 */}
         <button onClick={() => dispatch(add())}>+</button>
         <button onClick={() => dispatch(decrement())}>-</button>
         <button onClick={() => dispatch(addByNum(5))}>+5</button>
         <button onClick={() => dispatch(addByNum(-5))}>-5</button>
         {/* 渲染列表 */}
         <ul>
         {channelList.map(item => <li key={item.id}>{item.name}</li>)}
         </div>
      )
   }
   ```
4. **异步操作**
   (1)创建store写法不变，配置好同步修改状态的代码
   (2)单独封装一个函数，在函数内部return一个新函数，在新函数中封装异步请求获取数据，调用同步actionCreator方法传入异步数据生成action对象，使用dispatch方法提交
   (3)组件中dispatch写法保持不变
   例子: 渲染列表数据
   ```jsx
   // 创建channelStore.js
   import { createSlice } from '@reduxjs/toolkit'
   import axios from 'axios'
   // 创建store
   const channelStore = createSlice({
      name: 'channel',
      initialState: {
         channelList: []
      },
      reducers: {
         setChannelList(state, action) {
            state.channelList = action.payload
         }
      }
   })
   // 异步获取数据
   const { setChannelList } = channelStore.actions
   const getChannelList = () => {
      return ()=>{
         const res = axios.get('/example/xxx')
         dispatch(setChannelList(res.data.data))
       }
   }
   export { fetchChannelList }
   const reducer = channelStore.reducer
   export default reducer
   ```
### 九、React Router
1. **React Router**: React Router是一个用于管理路由的库，用于实现单页面应用中的路由功能。
2. **使用React Router**:
   (1)安装工具: `npm i react-router-dom`
   (2)创建路由组件: 
   首先在pages文件夹下创建路由组件，比如`Home.js`、`About.js`、`Contact.js`...
   随后在router文件夹下的index.js文件中配置路由关系:
   ```jsx
   // index.js
   import Home from '../pages/Home';
   import About from '../pages/About';
   import {createBrowserRouter} from 'react-router-dom';

   // 创建router实例对象并配置路由对应关系
   const router = createBrowserRouter([
      {
         path: '/login', // 路由路径
         element: <Login />, // 路由组件
      },
      {
         path: '/about',
         element: <About />,
      }
   ])
   // 导出router实例对象
   export default router;
   ```
   最后将router实例对象注入到src下的index.js文件中:
   ```jsx
   import React from 'react';
   import ReactDOM from 'react-dom/client';
   import App from './App';
   import {RouterProvider} from 'react-router-dom';
   // 引入router实例对象
   import router from './router';
   const root = ReactDOM.createRoot(document.getElementById('root'));
   root.render(
   <React.StrictMode>
      <RouterProvider router={router} />
   </React.StrictMode>
   )
   ```
3. **路由跳转**:
   (1)声明式路由: 使用`<Link>`标签声明路由跳转: `<Link to="/about">About</Link>`
   该组件最终会被渲染成`<a href="/about">About</a>`标签
   (2)编程式跳转: 使用`useNavigate()`方法实现路由跳转: 
   ```jsx
   import { useNavigate } from 'react-router-dom';
   function Home() {
      const navigate = useNavigate();
      return (
         <div>
         <button onClick={() => navigate('/about')}>跳转到About页面</button>
         <button onClick={() => navigate(-1)}>返回上一页</button>
         </div>
      )
   }
   ```
4. **路由参数**:
   路由导航传参:
   **`useSearchParams`传参:**
   `<button onClick={() => navigate('/about?id=xxx&name=xxx')}>跳转到About页面</button>`
   获取参数:
   ```js
   import { useSearchParams } from 'react-router-dom';
   const About = () => {
      const [params] = useSearchParams();
      // 获取参数
      const id = params.get('id');
      const name = params.get('name');
      return (
         <div> id: {id} name: {name} </div>
      )
   }
   export default Home;
   ```
   **`params`传参:**
   `<button onClick={() => navigate('/about/xxx/xxx')}>跳转到About页面</button>`
   在router中还需要在路径中配置参数: `path: '/about/:id/:name'`
   获取参数:
   ```js
   import { useParams } from 'react-router-dom';
   const About = () => {
      const { id, name } = useParams();
      return (
         <div> id: {id} name: {name} </div>
      )
   }
   export default About;
   ```
5. **嵌套路由**:
   (1)使用`children`属性声明嵌套关系: 
   ```jsx
   {
      path: '/',
      element: <Layout />,
      children: [
         {
            // 默认路由, 当设置为true时，页面自动渲染该组件
            index: true,
            element: <Home />
         },
         {
            path: '/about',
            element: <About />
         },
         ...
      ]
   }
   ```
   (2)使用`Outlet`组件实现嵌套关系: 
   ```jsx
   const Layout = () => {
      return (
         <div>
         <Link to="/about">About</Link>
         {/* 二级路由出口 */}
         <Outlet />
         </div>
      )
   }
   ```
6. **404页面配置**:
   (1)准备404页面组件: `<NotFound />`
   ```jsx
   const NotFound = () => {
      return (
         <div>404 Not Found</div>
      )
   }
   export default NotFound;
   ```
   (2)配置404页面: 
   ```jsx
   {
      path: '*',
      element: <NotFound />
   }
   ```
7. **路由模式**:
   `history`模式: 表现为`url/xxx`，由`history`对象和`pushState`事件实现，需要后端支持，由`createBrowserRouter`创建
   `hash`模式: 表现为`url/#/xxx`，监听`hashChange`事件实现，不需要后端支持，由`createHashRouter`创建
### 十、项目开发的必要依赖
1. **创建项目**: `npx create-react-app my-app`
2. **Redux状态管理**: `npm i @reduxjs/toolkit react-redux`
3. **路由**: `npm i react-router-dom`
4. **时间处理**: `npm i dayjs`
5. **class类名处理**: `npm i classnames`
6. **组件库**: `npm i antd-mobile`
7. **请求插件**: `npm i axios`
8. **安装scss**: `npm i sass -D`
9. **安装ant Design**: `npm i antd --save`
### 十一、使用CRA初始化项目环境
1. **创建项目**: `npx create-react-app my-app`
2. **规范整理项目目录**:
   **`apis`**: 存放所有接口请求文件
   **`assets`**: 存放静态资源文件
   **`components`**: 存放所有组件文件
   **`pages`**: 存放所有页面文件
   **`router`**: 存放所有路由文件
   **`store`**: 存放所有redux文件
   **`utils`**: 存放所有工具函数文件
3. **项目路径别名`@`配置**:
   ```jsx
   // 创建craco.config.js文件
   const path = require('path');
   module.exports = {
      // webpack配置
      webpack: {
         // 配置路径别名
         alias: {
            // 约定：路径别名必须以 @ 开头
            '@': path.resolve(__dirname, 'src')
         }
      }
   }
   ```
   此时，还需要在package.json文件中添加如下配置:
   ```json
   "scripts": {
   "start": "craco start",
   "build": "craco build",
   }
   ```
   最后，再在jsconfig.json文件中添加如下配置:
   ```json
   "compilerOptions": {
      "baseUrl": "./",
      "paths": {
         "@/*": ["src/*"]
      }
   }
   ```
### 十二、项目打包
1. **打包**: `npm run build`
2. **启动服务**: `serve -s build`
### 十三、路由懒加载
1. 在router中使用lazy函数实现路由懒加载:
   ```jsx
   import {lazy} from 'react';
   const Home = lazy(() => import('@/pages/Home'));
   ...
   // 在router中使用<Suspense>组件包裹
   const router = createBrowserRouter([
      {
         path: '/',
         element: <Layout />,
         children: [
            {
               index: true,
               element: <Suspense fallback={'加载中'}><Home /></Suspense>
            }
         ]
      }
   ])
   ```
### 十四、包体积可视化
1. **安装包体积可视化工具**: `npm i source-map-explorer`
2. **在package.json文件中添加如下配置**: 
   ```json
   "scripts": {
      "analyze": "source-map-explorer 'build/static/js/*.js'"
   }
   ```
3. **执行命令**: `npm run analyze`
### 十五、CDN优化
1. **CDN**: CDN是一种内容分发网络，用户请求网站内容时，由离用户最近的服务器将缓存的资源内容传递给用户。
2. **哪些资源可以放入CDN**: 体积大的非业务JS文件，如react、react-dom等
3. **配置方法**:
   在`craco.config.js`的webpack配置中添加CDN的配置项：
   ```javascript
   configure: {webpackConfig} => {
      let CDN
      whenProd(() => {
         webpackConfig.externals = {
            // key: 不参与打包的包名
            // value: cdn文件中，挂在于全局的变量名
            react: 'React',
            'react-dom': 'ReactDOM'
         }
         // 配置cdn资源地址
         cdn = {
            js: [
               'https://xxxx',
            ]
         }
      })
   }
   ```
4. **在index.html中引入cdn资源**
   ```html
   <% htmlWebpackPlugin.options.cdn.js.forEach(cdnURL => { %>
   <script src="<%= cdnURL %>"></script>
   <% }) %>
   ```
### 十六、关于useReducer
1. **useReducer**: 和`useState`类似，用来管理相对复杂的状态数据。
2. **使用**:(以数字增加减少功能为例)
   (1)定义一个reducer函数(根据不同的action返回不同状态)
   (2)在组件中调用useReducer, 并传入reducer函数和初始状态值
   (3)事件发生时，通过dispatch方法分派一个action，通知reducer更新哪个状态并渲染UI
   ```javascript
   function reducer(state, action) {
      switch (action.type) {
         case 'add':
            return state + 1;
         case 'minus':
            return state - 1;
            // 传参
         case 'set':
            return action.payload;
         default:
            return state;
      }
   }
   function App() {
      const [state, dispatch] = useReducer(reducer, 0);
      return (
         <div>
           <p>{state}</p>
           <button onClick={() => dispatch({ type: 'add' })}>+</button>
           <button onClick={() => dispatch({ type: 'minus' })}>-</button>
           <button onClick={() => dispatch({ type: 'set', payload: 5 })}>Set to 5</button>
         </div>
      )
   }
   ```
### 十七、关于useMemo
1. **useMemo**: 是一个 React Hook，组件每次重新渲染时，缓存计算的结果。
   用于计算量极大的数据
2. **使用**: (以计算斐波那契数列为例)
   ```jsx
   function fbi(n) {
      console.log('函数被执行了...');
      if (n < 3) return 1;
      return fbi(n - 2) + fbi(n - 1);
   } 
   function App() {
      const [num1, setNum1] = useState(0);
      // const result = fbi(num1); // 此时点击num2, 依然会执行fbi函数
      const result = useMemo(() => fbi(num1), [num1]); // 只有num1变化时才会执行fbi函数
      const [num2, setNum2] = useState(0);
      console.log('组件被渲染了...');
      return (
         <div>
         <button onClick={() => setNum1(num1 + 1)}>num1</button>
         <button onClick={() => setNum2(num2 + 1)}>num2</button>
         {result}
         </div>
      )
   }
   ```
### 十八、关于React.memo
1. **`React.memo`**: 允许在Props没有改变时，跳过组件渲染。
   由于父组件重新渲染，子组件也会跟着渲染，如果子组件本身没有重新渲染的需求，则会存在浪费。
2. **React.memo与prop的比较机制**:
   机制: 在使用memo缓存组件后，`React`会对每一个prop使用`Object.is()`进行比较，若返回true则认为prop没有变化。
   `prop`的比较:
   (1)当prop是简单类型时，如`Object.is(1, 1)`返回true，因为1和1是相同的值。
   (2)当prop是引用类型时，如`Object.is([1, 2], [1, 2])`返回false，因为`[1, 2]`和`[1, 2]`是两个不同的对象，React只关心对象的引用是否相同。
   若希望比较引用类型中的值的变化，则需要使用`useMemo`
   ```jsx
   import { memo, useState } from 'react'

   const ChildMemo = memo(function Child({ list }) {
      // memo可以跳过子组件渲染。
      console.log('子组件被渲染了...'); 
      return (
         <div>Son</div>
      )
   })
   /*function Child(props) {
      // 此时点击按钮，数字变化，子组件也会重新渲染
      console.log('子组件被渲染了...'); 
      return (
         <div>Son</div>
      ) 
   }*/
   function App() {
      // const [count, setCount] = useState(0); 当比较简单类型时，不需要使用useMemo
      const list = useMemo(() => [1, 2, 3], []) 
      <div>
         <ChildMemo list={list} />
         <button onClick={() => setCount(count + 1)}>{count}</button>
         <Child/>
      </div>
   }
   ```

