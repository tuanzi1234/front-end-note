### 一、初始化react项目
1. **创建项目**
   执行命令: `npx create-react-app my-app`
   其中`npx`是Node.js的命令; `create-react-app`是react核心包; `my-app`是项目的名称
### 二、JSX语法
   JSX是JS语法的扩展，浏览器本身不识别，需要通过解析工具才能在浏览器中运行
1. **JS表达式**
   在JSX中，你可以使用{}来包含JS表达式
   ```jsx
   const getName = () => 'zhangsan';
   const number = 1;
   function APP() {
      return (
      <div className="App">
         Hello World！
         {/* 使用引号传递字符串 */}
         {'Hello World'}
         {/* 识别变量 */}
         {number}
         {/*函数调用*/}
         {getName()}
         {/*方法调用*/}
         {new Date().toLocaleTimeString()}
         {/*JS对象*/}
         <div style={{color: 'red'}}>hello world</div>
      </div>
      )
   }
   ```
2. **列表渲染**
   ```jsx
   const list = [
      {id: 1, name: '张三'},
      {id: 2, name: '李四'},
      {id: 3, name: '王五'}
   ];
   function APP() {
      return (
         <div className="App">
            <ul>
            {/* 列表渲染 */}
            {/* 一定要加上独立的key属性，react内部使用，用于提升性能 */}
            {list.map(item => <li key={item.id}>{item.name}</li>)}
            </ul>
         </div>
      )
   }
   ```
3. **条件渲染**
   ```jsx
   // 通过布尔值来判断内容是否显示
   const isLogin = true;
   function APP() {
      return (
         <div className="App">
         {/* 逻辑运算符 */}
         {isLogin && <div>已登录</div>}
         {/* 三元运算符 */}
         {isLogin ? <div>已登录</div> : <div>未登录</div>}
         </div>
      )
   }
   ```
   **复杂条件渲染**
   ```jsx
   const type = 2;
   function getType() { 
      if (type === 1) {
         return <div>类型1</div>
      } else {
         return <div>其他类型</div>
      }
   }
   function APP() {
      return (
         <div className="App">
         {getType()}
         </div>
      )
   }
   ```
6. **事件绑定**
   ```jsx
   const handleClick = (name, e) => {
      console.log(name, e)
   }
   function APP() {
      return (
         <div className="App">
         {/* 绑定事件, 根据需要传递参数 */}
         <button onClick={(e) => handleClick('张三', e)}>点击</button>
         </div>
      )
   }
   ```
### 三、组件的封装与使用
   ```jsx
   // 定义组件
   function Button() {
      return <button>点击</button>
   }
   function App() {
      return (
         <div className="App">
         {/* 使用组件 */}
         <Button />
         </div>
      )
   }
   ```
### 四、状态管理
1. **useState是React Hooks，允许我们向组件添加一个状态变量，影响组件的渲染结果**
   ```jsx
   // 其中，useState()是一个函数，返回一个数组
   // 数组中第一个参数是状态变量，第二个参数是set函数，用来修改状态变量
   // useState()的参数是初始值
   const [count, setCount] = useState(0);
   ```
   **状态修改的规则**
   1.状态变量不能直接修改，必须通过set函数来修改
   2.对于对象类型的状态变量，应当始终传给set方法一个新的对象修改
2. **classnames优化类名**
    1.安装classnames包：`npm install classnames`
    2.引入classnames包：`import classnames from 'classnames'`
    3.使用classnames包： `className={classnames('active', {disabled: isDisabled})}`
3.  **表单受控绑定**
    1.准备react状态值: `const [value, setValue] = useState('');`
    2.通过value属性绑定状态，通过onChange属性绑定状态同步函数
    `<input type="text" value={value} onChange={(e) => setValue(e.target.value)} />`
4.  **react获取DOM元素**
    使用useRef创建ref对象, 并与JSX绑定
    `const inputRef = useRef(null);`
    `<input type="text" ref={inputRef} />`
5.  **id和日期处理**
    **处理id**: 
    使用`npm install uuid`安装uuid包，
    引入uuid包: `import { v4 as uuidv4 } from 'uuid';`
    在需要的地方直接使用方法: `uuidv4()`
    **处理日期**:
    使用`npm install dayjs`安装dayjs包
    引入dayjs包: `import dayjs from 'dayjs';`
    在需要地方使用方法: `dayjs().format('YYYY-MM-DD HH:mm:ss')`
### 五、组件通信
1. **父组件向子组件传递数据**
   (1)父组件传递数据： `<ChildComponent data={data} />`子组件上绑定属性
   (2)子组件接收数据： 使用props接收数据:
   ```jsx
   function ChildComponent(props) {
   return (
   <div>{props.data}</div>
   )}
   ```
   **关于props**: 
   (1)props可以传递任意数据，数字，字符串，对象，数组，函数，JSX等等
   (2)props是只读的，不能修改props中的数据，若要修改数据只能由父组件进行
   (3)当内容嵌套在子组件标签中时，父组件会自动在children的prop中接收内容
2. **子组件向父组件传递数据**
   在子组件中调用父组件的方法，传递参数
   ```jsx
   // 子组件
   function ChildComponent({onGetData}) {
      const sonData = '子组件数据'
      return (
         <button onClick={() => onGetData(sonData)}>点击获取数据</button>
      )
   }
   // 父组件
   function ParentComponent() {
       // 存储数据
      const [data, setData] = useState('')
      const getData = (data) => {
         console.log(data)
         setData(data)
      }
      return (
         <div>{data}</div>
         <ChildComponent onGetData={getData} />
      )
   }
   ```
3. **兄弟组件通信**
   借助状态提升，通过父组件进行兄弟组件间的通信
   ```jsx
   // 1.通过子组件A向父组件传递数据
   function ChildA({onGetData}) {
      const data = '子组件A数据'
      return (
         <button onClick={() => onGetData(data)}>点击获取数据</button>
      )
   }
   // 2.通过父组件向子组件B传递数据
   function ParentComponent() {
      const [data, setData] = useState('')
      const getData = (data) => {
         console.log(data)
         setData(data)
      }
      return (
         <ChildA onGetData={getData} />
         <ChildB data={data} />
      )
   }
   // 3.子组件B接收数据
   function ChildB(props) {
      return (
         <div>{props.data}</div>
      )
   }
   ```
4. **利用context跨层通信**
   (1)使用createContext创建context对象
   (2)在顶层组件(App)中通过Provider组件提供数据
   (3)在底层组件(B)中通过useContext接收数据
   ```jsx
   import { createContext, useContext } from 'react';
   // 创建context对象
   const MyContext = createContext();
   function App() {
      const data = 'hello world';
      return (
         <div>
         {/* 提供数据 */}
         <MyContext.Provider value={data}>
         <A />
         </MyContext.Provider>
         </div>
      )
   }
   function A() {
      return (
         <div>A</div>
         <B />
      )
   }
   function B() {
      // 跨过A组件接收数据
      const data = useContext(MyContext);
      return (
         <div>{data}</div>
      )
   }
   ```
### 六、useEffect
1. **useEffect用于在React组件中创建不是由事件引起，而是由渲染本身引起的操作。**
   比如Ajax请求，更改DOM等等。
   例如: 组件渲染完毕后立即获取数据:
   ```jsx
   import { useEffect, useState } from 'react';

   function App() {
      const [data, setData] = useState([]);
      useEffect(() => {
         async function fetchData() {
            const res = await fetch('https://api.example.com/data');
            const data = await res.json();
            setData(data);
         }
         fetchData();
      }, [])
      return (
         <div>{data}</div>
      )
   }
   ```
2. **useEffect的参数**: 
   1.第一个参数是一个函数，这个函数会在组件渲染完毕后执行
   2.第二个参数是一个数组，是传入的依赖项，根据参数不同，有不同表现：
   (1)没有依赖项时，副作用函数会在组件渲染完毕后执行一次，并且每次组件更新时都会执行一次
   (2)传入一个空数组时，副作用函数只会在组件渲染完毕后执行一次
   (3)特定依赖项，副作用函数会在组件初始渲染时执行一次，特定依赖项变化时再次执行
3. **清除副作用**: 
   例如在useEffect中启动了一个定时器，在组件销毁时需要清除定时器，这就是清理副作用。
   该函数会在组件销毁时自动执行。
   ```jsx
   import { useEffect, useState } from 'react';
   function Son() {
      useEffect(() => {
         const timer = setInterval(() => {
            console.log('定时器执行中...')
         }, 1000)
      })
      return () => {
         clearInterval(timer)
      }
      return <div>子组件</div>
   }
   function App() {
      const [show, setShow] = useState(true);
      return (
         <div>
         {show && <Son />}
         <button onClick={() => setShow(false)}>删除子组件</button>
      )
   }
   ```
### 七、自定义hooks
1. **自定义hooks**: 以use开头的函数，可以封装一些通用逻辑，方便复用。
   **思路**: 
   (1)封装一个函数，函数名以use开头
   (2)函数内部封装逻辑(可复用的逻辑均可封装)
   (3)返回一个对象，对象中包含需要使用的变量和函数
   (4)在组件中用到这个逻辑就执行该函数，解构出状态和回调进行使用
   ```jsx
   import { useState } from 'react';
   // 自定义hooks，使show, setShow能够被其他组件使用, 控制组件的显示和隐藏
   function useToggle() {
      const [show, setShow] = useState(true);
      const toggle = () => setShow(!show);
      return {show, toggle};
   }
   function App() {
      const {show, toggle} = useToggle();
      return (
         <div>
         {show && <div>内容</div>}
         <button onClick={toggle}>{show ? '显示' : '隐藏'}</button>
         </div>
      )
   }
   ```
2. **ReactHook的使用规则**:
   (1)只能在组件中或其他自定义Hook中调用
   (2)只能在组件的顶层调用，不能嵌套在if、for、其他函数中
### 八、Redux
1. **Redux**: Redux是一个状态管理库，用于管理React应用中的状态，类似于Vuex和Pinia。
2. **使用Redux**: 
   (1)定义一个 **`reducer`函数(根据当前想做的修改返回一个全新的状态)**
   (2)使用`createStore`方法传入`reducer`函数，创建一个 **`store`对象(存放着管理数据的状态)**
   (3)使用`store.subscribe`方法订阅`store`对象，监听状态的变化，数据变化即可得到通知
   (4)使用`store.dispatch`方法提交一个 **`action`对象(描述如何改数据)**，触发数据变化(告诉`reducer`应当如何改数据)
   (5)使用`store.getState`方法获取当前最新状态更新到视图中
3. **Redux和React的环境准备**:
   安装工具: `npm i @reduxjs/toolkit react-redux` 
   **使用:**
   例子：利用ReduxToolkit实现数字增减
   ```jsx
   // 创建counterStore.js
   import { createSlice } from '@reduxjs/toolkit';

   const counterStore = createSlice({
      name: 'counter',
      // 初始状态
      initialState: {
         count: 0,
      },
      // 修改数据的同步方法
      reducers: {
         add: (state) => {
            state.count++
         },
         decrement: (state) => {
            state.count--
         },
         // 传参
         addByNum: (state, action) => {
            state.count += action.payload
         }
      }
   })
   // 解构出action对象的函数
   const { add, decrement } = counterStore.actions;
   // 获取reducer对象
   const counterReducer = counterStore.reducer;
   // 导出action对象的函数和reducer函数
   export { add, decrement };
   export default counterReducer;
   ```
   ```jsx
   // 创建store.js
   import { configureStore } from '@reduxjs/toolkit';
   import counterReducer from './counterStore';
   // 引入channelStore.js异步功能
   import channelReducer from './channelStore';

   // 创建根store组合子模块
   const store = configureStore({
      reducer: {
         counter: counterReducer,
         channel: channelReducer
      }
   })
   export default store;
   ```
   ```jsx
   // 在react中注入store
   import { Provider } from 'react-redux';
   import store from './store';

   const root = ReactDOM.createRoot(document.getElementById('root'));
   root.render(
      <Provider store={store}>
      <App />
      </Provider>
   )
   ```
   ```jsx
   // React组件中使用store的数据，使用useSelector
   // React组件修改store的数据，使用useDispatch
   import { useSelector, useDispatch } from 'react-redux';
   // 引入action对象的方法
   import { add, decrement, addByNum } from './counterStore';
   //引入异步方法函数
   import { getChannelList } from './channelStore';
   function App() {
      const {count} = useSelector(state => state.counter);// 与reducer中的属性名对应
      const {channelList} = useSelector(state => state.channel);// 将channelList数据解构到组件
      const dispatch = useDispatch(); // 获取dispatch方法
      // 使用useEffect触发移除请求执行
      useEffect(() => {
         dispatch(getChannelList());
      }, [dispatch])
      return (
         <div>
         <h1>{count}</h1>
         {/* 调用dispatch方法，触发action对象，修改数据 */}
         <button onClick={() => dispatch(add())}>+</button>
         <button onClick={() => dispatch(decrement())}>-</button>
         <button onClick={() => dispatch(addByNum(5))}>+5</button>
         <button onClick={() => dispatch(addByNum(-5))}>-5</button>
         {/* 渲染列表 */}
         <ul>
         {channelList.map(item => <li key={item.id}>{item.name}</li>)}
         </div>
      )
   }
   ```
4. **异步操作**
   (1)创建store写法不变，配置好同步修改状态的代码
   (2)单独封装一个函数，在函数内部return一个新函数，在新函数中封装异步请求获取数据，调用同步actionCreator方法传入异步数据生成action对象，使用dispatch方法提交
   (3)组件中dispatch写法保持不变
   例子: 渲染列表数据
   ```jsx
   // 创建channelStore.js
   import { createSlice } from '@reduxjs/toolkit'
   import axios from 'axios'
   // 创建store
   const channelStore = createSlice({
      name: 'channel',
      initialState: {
         channelList: []
      },
      reducers: {
         setChannelList(state, action) {
            state.channelList = action.payload
         }
      }
   })
   // 异步获取数据
   const { setChannelList } = channelStore.actions
   const getChannelList = () => {
      return ()=>{
         const res = axios.get('/example/xxx')
         dispatch(setChannelList(res.data.data))
       }
   }
   export { fetchChannelList }
   const reducer = channelStore.reducer
   export default reducer
   ```
   

