### 一、nodejs
1. **nodejs**: nodejs是JavaScript运行环境，使用nodejs可以编写服务器端程序。
### 二、fs模块
2. **fs模块**: fs模块是nodejs的文件系统模块，用于操作文件。
```javascript
// 创建fs模块
const fs = require('fs');
// 创建文件
fs.writeFile('test.txt', 'hello world',  (err) => { 
  if (err) throw err;
  else console.log('写入成功！');
});
```
3. **path模块**: path模块是nodejs的路径模块，用于操作路径。
   尽量在nodejs中使用绝对路径
   使用path.join()方法来拼接路径
   内置变量`__dirname`: 当前文件所在目录的绝对路径
```javascript
// 读取文件
fs.readFile(path.join(__dirname, '../test.txt'), 'utf8', (err, data) => { 
  if (err) throw err;
  else console.log(data.toString());
});
```
压缩文件案例：
```javascript
//创建fs模块
const fs = require('fs');
const path = require('path');
fs.readdir(path.join(__dirname, 'fileName'), (err, files) => {
  if (err) throw err;
  else {
    const htmlStr = files.toString();
    //替换字符空字符串
    const resultStr = htmlStr.replace(/[\r\n]/g, '');
    //写入到dist目录下的压缩文件中
    fs.writeFile(path.join(__dirname, 'dist/index.html'), resultStr, (err) => {
      if (err) throw err;
      else console.log('压缩成功');
    })
  }
 })
```
### 三、http模块
http模块是nodejs内置的模块，用于创建http服务器
```javascript
// 引入http模块
const http = require('http');
const server = http.createServer()
//监听request请求事件
server.on('request', (req, res) => { 
  res.setHeader('Content-Type', 'text/html;charset=utf-8');
  res.end('<h1>Hello World</h1>');
});
//分配端口号
server.listen(8080, () => {
  console.log('server running at http://127.0.0.1:8080');
});
```
### 四、模块化
在Node.js中，每一个文件都是一个单独的模块
1. **CommonJS模块化**
   1.导出：module.exports = {}
   2.导入：const moduleName = require('模块名')
   3.若是内置模块，直接写名字(fs/path/http)；若是自定义模块，则需要写路径(./模块名)
```javascript
//导出
const baseURL = 'http://127.0.0.1:8080';
const getArr = arr => arr.reduce((sum, item) => sum += item, 0)
module.exports = { 
  url: baseURL,
  arr: getArr
 }
 //导入
 const obj = require('./01.js')
 console.log(obj)
 const result = obj.arr([1,2,3,4,5])
 console.log(result)
 ```
2. **ECMAScript模块化**
  **默认标准使用**
  导出：export default {}
  导入：import {变量名} from '模块名'
  **注：** Nodejs默认支持CommonJS语法
  若要使用ECMAScript模块化，需要新建一个package.json文件，并添加`{"type": "module"}`
  **命名导出和导入**
  导出：在需要导出的对象定于语句前加上`export`
  导入：`import {同名变量名} from '模块名'`
### 五、包
1. **包:** 将模块、代码、其他资料聚合成一个文件夹
2. **包的分类:** 
   1.项目包：主要用于编写项目和业务逻辑
   2.软件包：封装工具和方法进行使用
  **要求：** 根目录中必须要有package.json文件用于记录包的清单信息
3. **清单信息：**
```json
{
"name": "软件包的名称",
"version": "软件包的版本号",
"description": "软件包的描述",
"main": "入口文件",
"author": "软件包的作者",
"license": "软件包的授权协议"
}
```
### 六、npm
1. **npm**: npm是nodejs的包管理工具，用于安装、卸载、更新包
2. **npm命令**: 
   `npm init -y`: 初始化项目，得到package.json文件
   `npm install 包名`: 安装包，若省略具体包名，则安装package.json文件中记录的所有依赖包
3. **全局软件包-nodemon**:
   本地软件包：当前项目内使用，封装属性和方法，存在于项目的node_modules目录下
   全局软件包：本机所有项目使用，封装属性和方法 
   `npm install -g nodemon`: 安装全局软件包nodemon
### 七、webpack
1. **webpack**: 模块打包工具，将多个模块打包成一个文件
   将less/sass转成css代码
   把ES6代码转成ES5代码
   支持多模块标准化语法
2. **使用**:
   下载webpack到当前项目(版本独立): `npm install webpack webpack-cli --save-dev`
   在package.json中添加配置: `"scripts": { "build": "webpack" }`
   运行: `npm run build` 此时会在项目中自动产生dist文件夹，压缩优化后，用于最终运行的代码
3. **修改入口/出口**:
   在webpack.config.js中修改入口和出口:
```javascript
const path = require('path');
module.exports = {
  entry: './src/index.js',  // 入口文件
  output: {
    path: path.resolve(__dirname, 'dist'), // 出口路径
    filename: 'bundle.js', // 出口文件
    clean: true, // 生成打包文件前清空dist目录
  }
}
```
4. **自动生成HTML文件**:
   **安装：** `npm install html-webpack-plugin --save-dev`
   **使用：**
   在webpack.config.js中引入html-webpack-plugin:
```javascript
const HtmlWebpackPlugin = require('html-webpack-plugin');
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: './src/index.html' // 模板文件
      fileName: path.resolve(__dirname, 'dist/index.html'), //输出文件
    })
  ]
}
```
5. **打包css代码**:
   1.安装css-loader和style-loader: `npm install css-loader style-loader --save-dev`
   2.把css代码引入index.js中： `import css from './index.css'`;
   3.在webpack.config.js中配置css-loader:
   ```javascript
   module.exports = {
    module: {
      rules: [
        {
          test: /\.css$/i,
          use: ["style-loader", "css-loader"]
        }
      ]
    }
   }
   ```
   **单独提取css代码打包压缩**:
   1.安装css-loader和mini-css-extract-plugin： `npm install css-loader mini-css-extract-plugin --save-dev`;
   2.安装css-minimizer-webpack-plugin： `npm install css-minimizer-webpack-plugin --save-dev`;
   2.在webpack.config.js中配置css-loader/mini-css-extract-plugin/css-minimizer-webpack-plugin:
   ```javascript
   const MiniCssExtractPlugin = require("mini-css-extract-plugin");
   const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
   module.exports = {
    module: {
      rules: [
        {
          test: /\.css$/i,
          use: [MiniCssExtractPlugin.loader, "css-loader"]
        },
      ],
    },
    plugins: [
      new MiniCssExtractPlugin({
        filename: "[name].css",//可在该对象中指定文件名以及文件存放位置
      }),
    ]
    optimization: {
      minimizer: [
        '...',
        new CssMinimizerPlugin(),
      ]
    }
   }
   ```
6. **打包less代码**:
   1.将需要打包的less代码引入到src/login/index.js文件中
   2.下载less和less-loader本地软件包 `npm i less less-loader -save-dev`
   3.配置webpack.config.js文件：
   ```javascript
   import './index.less'
   const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");
   module.exports = {
    module: {
      rules: [
        {
          test: /\.less$/i,
          //在package.json中配置了环境变量后即可使用判断语句转向不同的环境
          use: [process.env.NODE_ENV === 'development' ? 'style-loader', 'css-loader', 'less-loader']
        },
      ]
    }
   }
   ```
7. **打包图片**：
   配置webpack.config.js文件：
   判断临界值为8KB，大于8KB会发送一个单独图片并导出url地址，小于8KB会导出一个data url。
   占位符：
   `[hash]`: 对模块内容做算法计算，得到映射的数字字母组合的字符串
   `[ext]`: 使用当前模块原本的占位符，例如`.png`等
   `[query]`: 保留引入文件时代码的查询参数(只有URL下生效)
   ```javascript
   module.exports = {
    module: {
      rules: [
        {
          test: /\.(png|jpg|jpeg|gif)$/i,
          type: 'asset',
          generator: {
            filename: 'images/[hash][ext][query]'
          }
        }
      ]
    }
   }
   ```
8. **搭建开发环境**:
   1.下载webpack-dev-server软件到当前项目: `npm install webpack-dev-server --save-dev`
   2.设置开发模式，配置自定义命令
   在index.js中添加如下代码
   ```javascript
   module.exports = {
    mode: 'development',
   }
   ```
   3.运行自定义命令，启动开发服务器：`npm run dev`
   在package.json文件中添加以下内容
   ```json
   "scripts": {
    "build": "webpack",
    "dev": "webpack serve --open"
   }
   ```
  **注意事项**:
  1.`webpack-dev-server`借助http模块创建8080默认Web服务
  2.默认以public目录作为服务器根目录
  3.`webpack-dev-server`会根据配置，打包相关代码在内存中，以output.path为根目录
  可以在public目录下创建index.html文件，然后在script标签中写`location.href = '/目标页面路径'`来阻止他直接访问public目录。
9. **打包模式**:
   开发模式：调试代码，实时加载，模块热替换
   生产模式：压缩代码，资源优化，更轻量
   **使用：**
   方式一：在webpack.config.js中添加`mode: 'development'`或者`mode: 'production'`(不推荐)
   方式二：在package.json中添加
   `"scripts": { "dev": "webpack serve --open --mode=development", "build": "webpack --mode=production" }`
   **利用方式二配置不同的环境变量**
   1.引入cross-env: `npm i cross-env --save-dev`
   2.在package.json中添加 
   ```json
   "scripts": {
    "dev": "cross-env NODE_ENV=development webpack serve --open --mode=development",
    "build": "cross-env NODE_ENV=production webpack --mode=production"
   }
   ```
   3.在webpack.config.js中添加
   ```javascript
   const webpack = require('webpack');
   module.exports = {
    plugins: [
      new webpack.DefinePlugin({
        process.env.NODE_ENV: JSON.stringify(process.env.NODE_ENV) //此时便可在项目中访问环境变量
      })
    ]
   }
   ```
10. **webpack开发环境调错**
    可以使用`inline-source-map`定位错误位置
    **使用：** 在webpack.config.js中添加
    ```javascript
    const config = {...}
    if (process.env.NODE_ENV === 'development') { 
      config.devtool = 'inline-source-map';
    }
    module.exports = config;
    ```
11. **设置路径别名**：
    在webpack.config.js中添加
    ```javascript
    const config = {
      resolve: {
        alias: {
          '@': path.resolve(__dirname, 'src') //在src目录下创建一个@别名，在其他地方使用@会自动从src目录下寻找文件
        }
      }
    }
    ```
12. **使用CDN技术**
    **CDN**：内容分发网络，是一组分布在各地区的服务器。
    **作用**: 把静态资源/第三方库放在CDN上，供用户就近获取
    **好处**: 减轻服务器压力
    **步骤**:
    1.在html中引入第三方库的CDN地址
    ```html
    <head>
    <% if(HtmlWebpackPlugin.options.useCdn) { %>
    <link href="https://cdn.bootcdn.net/ajax/libs/对应的框架" rel="stylesheet">
    <% } %>
    </head>
    <!-- script标签中若有第三方库的链接也需要做出上述操作-->
    ```
    2.在webpack.config.js中配置:
    ```javascript
    const config = {...}
    if (process.env.NODE_ENV === 'production') {
      config.externals = {
        //key: import from 语句后的字符串
        //value: 留在原地的全局变量(最好和cdn在全局暴露的变量一致)
        //例如：
        'bootstrap/dist/css/bootstrap.min.css': 'bootstrap',
        'axios': 'axios'
      }
    }
    ```
13. **多页面打包**:
    1.将多个页面的源码放入响应位置，并改用模块化语法导出
    2.下载from-serialize包并导入到核心代码中使用：`npm i from-serialize --save`
    3.配置webpack.config.js多入口和多页面设置
    例如：
    ```javascript
    const config = { 
      entry: {
        index: './src/index.js',
        list: './src/list.js'
      },
      output: { 
        path: path.resolve(__dirname, 'dist'),
        filename: './[name]/index.js'
        clean: true
      },
      plugins: [
        new HtmlWebpackPlugin({
          template: path.resolve(__dirname, 'src/index.html'),
          filename: path.resolve(__dirname, 'dist/index/index.html'),
          useCdn: process.env.NODE_ENV === 'production',
          chunk: ['index']
        }),
        new HtmlWebpackPlugin({
          template: path.resolve(__dirname, 'src/list.html'),
          filename: path.resolve(__dirname, 'dist/list/index.html'),
          useCdn: process.env.NODE_ENV === 'production',
          chunk: ['list']
        }),
        new MiniCssExtractPlugin({
          filename: './[name]/index.css'
        }),
        //...
      ]
    }
    ```
    